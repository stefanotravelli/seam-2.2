# Language fr-FR translations for PACKAGE package.
# Automatically generated, 2008.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2009-01-18 15:00+0000\n"
"PO-Revision-Date: 2009-08-11 16:11+0100\n"
"Last-Translator: P.J <essaidetest@yahoo.fr>\n"
"Language-Team: none\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. Tag: title
#: Concepts.xml:5
#, no-c-format
msgid "The contextual component model"
msgstr "Le modèle de composant contextuel"

#. Tag: para
#: Concepts.xml:6
#, no-c-format
msgid "The two core concepts in Seam are the notion of a <emphasis>context</emphasis> and the notion of a <emphasis>component</emphasis>. Components are stateful objects, usually EJBs, and an instance of a component is associated with a context, and given a name in that context. <emphasis>Bijection</emphasis> provides a mechanism for aliasing internal component names (instance variables) to contextual names, allowing component trees to be dynamically assembled, and reassembled by Seam."
msgstr "Les deux concepts centraux dans Seam sont la notion de  <emphasis>contexte</emphasis> et la notion de <emphasis>composant</emphasis>. Les composants sont des objets avec état, habituellement des EJBs, et une instance d’un composant est associé avec un contexte, et défini par un nom dans ce contexte. La <emphasis>Bijection</emphasis> fourni un mécanisme pour nommer les composants par un alias interne (les variables d’instances) dans les noms du contexte, autorisant des arbres de composants a être dynamiquement assemblés et réassemblés par Seam. "

#. Tag: para
#: Concepts.xml:14
#, no-c-format
msgid "Let's start by describing the contexts built in to Seam."
msgstr "Commençons par la description des contextes existant dans Seam. "

#. Tag: title
#: Concepts.xml:19
#, no-c-format
msgid "Seam contexts"
msgstr "Les contextes de Seam"

#. Tag: para
#: Concepts.xml:20
#, no-c-format
msgid "Seam contexts are created and destroyed by the framework. The application does not control context demarcation via explicit Java API calls. Context are usually implicit. In some cases, however, contexts are demarcated via annotations."
msgstr "Les contextes de Seam sont créés et détruit par le serveur de squelette d’application (framework) via des appels explicite à l’API Java. Les contextes sont habituellement implicites. Dans certains cas, malgré tout, les contextes sont spécifiés via des annotations. "

#. Tag: para
#: Concepts.xml:23
#, no-c-format
msgid "The basic Seam contexts are:"
msgstr "Les  contextes de base de Seam"

#. Tag: para
#: Concepts.xml:27
#, no-c-format
msgid "<para>Stateless context</para>"
msgstr "<para>Le contexte sans état</para>"

#. Tag: para
#: Concepts.xml:30
#, no-c-format
msgid "Event (i.e., request) context"
msgstr "Le contexte évènementiel (autrement dir, de requête)"

#. Tag: para
#: Concepts.xml:33
#: Concepts.xml:225
#, no-c-format
msgid "<para>Page context</para>"
msgstr "<para>Le contexte de Page</para>"

#. Tag: para
#: Concepts.xml:36
#: Concepts.xml:228
#, no-c-format
msgid "<para>Conversation context</para>"
msgstr "<para>Le contexte conversatinnel</para>"

#. Tag: para
#: Concepts.xml:39
#: Concepts.xml:231
#, no-c-format
msgid "<para>Session context</para>"
msgstr "<para>Le contexte de Session</para>"

#. Tag: para
#: Concepts.xml:42
#: Concepts.xml:234
#, no-c-format
msgid "<para>Business process context</para>"
msgstr "<para>Le contexte de processus métier</para>"

#. Tag: para
#: Concepts.xml:45
#: Concepts.xml:237
#, no-c-format
msgid "<para>Application context</para>"
msgstr "<para>Le contexte d'Application</para>"

#. Tag: para
#: Concepts.xml:49
#, no-c-format
msgid "You will recognize some of these contexts from servlet and related specifications. However, two of them might be new to you: <emphasis>conversation context</emphasis>, and <emphasis>business process context</emphasis>. One reason state management in web applications is so fragile and error-prone is that the three built-in contexts (request, session and application) are not especially meaningful from the point of view of the business logic. A user login session, for example, is a fairly arbitrary construct in terms of the actual application work flow. Therefore, most Seam components are scoped to the conversation or business process contexts, since they are the contexts which are most meaningful in terms of the application."
msgstr "Nous pouvons reconnaître certain de ces contexte de part les spécifications des servlets autour des servlets. Malgré cela, deux d’entre elles devraient être nouvelle pour vous : <emphasis>contexte conversationnel</emphasis>, et <emphasis>contexte de processus métier<emphasis>. Une des raisons pour que le gestionnaire d’état qui est dans les applications web, soit si fragile et un nid à erreurs c’est que trois des contextes livrés (requête, session et application) ne sont pas particulièrement utile du point de vue de la logique métier. Une session d’authentification d’un utilisateur, par exemple, est construite presque arbitrairement dans une application de flot de travail. Ainsi, les composants Seam sont bornés à la conversation ou aux contextes des processus métier, ainsi ils sont les contextes qui ont le plus de sens en termes d’application. "

#. Tag: para
#: Concepts.xml:60
#, no-c-format
msgid "Let's look at each context in turn."
msgstr "Ayons un regard sur chacun de ces contextes l'un après l'autre."

#. Tag: title
#: Concepts.xml:65
#, no-c-format
msgid "<title>Stateless context</title>"
msgstr "<title>Le contexte sans état</title>"

#. Tag: para
#: Concepts.xml:66
#, no-c-format
msgid "Components which are truly stateless (stateless session beans, primarily) always live in the stateless context (which is basically the absense of a context since the instance Seam resolves is not stored). Stateless components are not very interesting, and are arguably not very object-oriented. Nevertheless, they do get developed and used and are thus an important part of any Seam application."
msgstr "Les composants qui sont réellement sans état (les beans sessions sans état, principalement) vivent toujours dans un contexte sans état (ce qui est basiquement une absence de contexte). Les composants sans état ne sont pas vraiment intéressant et sont dénigrés pour ne pas être orienté objet. Malgré cela, ils sont importants, très souvent utile  et aussi une part important de toute application Seam."

#. Tag: title
#: Concepts.xml:75
#, no-c-format
msgid "<title>Event context</title>"
msgstr "<title>Le contexte évenementiel</title>"

#. Tag: para
#: Concepts.xml:76
#, no-c-format
msgid "The event context is the \"narrowest\" stateful context, and is a generalization of the notion of the web request context to cover other kinds of events. Nevertheless, the event context associated with the lifecycle of a JSF request is the most important example of an event context, and the one you will work with most often. Components associated with the event context are destroyed at the end of the request, but their state is available and well-defined for at least the lifecycle of the request."
msgstr "Le contexte d’évènement est le contexte avec état le plus \"réduit\", et est la généralisation de la notion du contexte d’une requête web pour couvrir les autres types d’évènements. Malgré cela, le contexte d’évènement associé avec un cycle de vue dans une requête JSF est l’exemple le plus important d’un contexte d’évènement, et le seul qui va fonctionner le plus souvent. Les composants associés avec un contexte d’évènement sont détruit à la fin de la requête, mais leurs état est disponible et bien définie pour au moins le cycle de vie de la requête."

#. Tag: para
#: Concepts.xml:83
#, no-c-format
msgid "When you invoke a Seam component via RMI, or Seam Remoting, the event context is created and destroyed just for the invocation."
msgstr "Quand vous invoquez un composant Seam via RMI ou Seam Remoting, le contexte d’évènement est créé et détruit juste pour l’invocation. "

#. Tag: title
#: Concepts.xml:90
#, no-c-format
msgid "<title>Page context</title>"
msgstr "<title>Le contexte de Page</title>"

#. Tag: para
#: Concepts.xml:91
#, no-c-format
msgid "The page context allows you to associate state with a particular instance of a rendered page. You can initialize state in your event listener, or while actually rendering the page, and then have access to it from any event that originates from that page. This is especially useful for functionality like clickable lists, where the list is backed by changing data on the server side. The state is actually serialized to the client, so this construct is extremely robust with respect to multi-window operation and the back button."
msgstr "Le contexte de page vous permet d’associer un état avec une instance particulière d’un page à rendre. Vous pouvez initialiser un état dans votre écouteur d’évènement ou au moment ou la page est en train d'être rendue et ensuite avoir un accès sur elle depuis tout évènement qui a comme origine cette page. Ceci est spécialement utile pour la fonctionnalité comme une liste cliquable quand la liste est controlée par une donnée changeante côté serveur. L’état est actuellement sérialisé vers le client, donc cette construction est extrêmement robuste dans le respect d’opération multi fenêtre et du bouton précédent."

#. Tag: title
#: Concepts.xml:102
#, no-c-format
msgid "<title>Conversation context</title>"
msgstr "<title>Le contexte conversationnel</title>"

#. Tag: para
#: Concepts.xml:103
#, no-c-format
msgid "The conversation context is a truly central concept in Seam. A <emphasis>conversation</emphasis> is a unit of work from the point of view of the user. It might span several interactions with the user, several requests, and several database transactions. But to the user, a conversation solves a single problem. For example, \"book hotel\", \"approve contract\", \"create order\" are all conversations. You might like to think of a conversation implementing a single \"use case\" or \"user story\", but the relationship is not necessarily quite exact."
msgstr "Le contexte de conversation est un vraiment un concept central dans Seam. Une <emphasis>conversation</emphasis> est une unité de travail du point de vue de l’utilisateur. Elle peut s’étendre sur plusieurs interactions de l’utilisateur, plusieurs requêtes, et plusieurs transactions de base de données. Mais pour l’utilisateur, une conversation résout un seul problème. Par exemple, \"réserver un hôtel\", \"valider un contact\", \"créer un bon de commande\" sont toutes des conversations. Vous devriez apprécier de penser en termes d’implémentation de la conversation comme un seul \"cas d’utilisation\" ou une \"exemple d’utilisation\" mais la relation n’est pas nécessairement aussi directe. "

#. Tag: para
#: Concepts.xml:111
#, no-c-format
msgid "A conversation holds state associated with \"what the user is doing now, in this window\". A single user may have multiple conversations in progress at any point in time, usually in multiple windows. The conversation context allows us to ensure that state from the different conversations does not collide and cause bugs."
msgstr "Une conversation retient un état associé avec \"ce que l’utilisateur est en train de faire maintenant dans cette fenêtre\". Un simple utilisateur peut avoir de multiples conversations en cours à tout moment dans le temps, habituellement dans de multiples fenêtres. Le contexte de conversation nous permet de nous assurer que cet état provenant de différentes conversations ne peut se caramboler et causer des bugs. "

#. Tag: para
#: Concepts.xml:117
#, no-c-format
msgid "It might take you some time to get used to thinking of applications in terms of conversations. But once you get used to it, we think you'll love the notion, and never be able to not think in terms of conversations again!"
msgstr "Il est possible que cela vous prennes du temps de maitriser la façon de penser l’application en termes de conversations. Mais une fois que vous avez l’habitude de le faire, nous pensons que vous allez adorer cette notion, et que vous ne serez plus capable de ne jamais  plus penser en termes de conversations! "

#. Tag: para
#: Concepts.xml:122
#, no-c-format
msgid "Some conversations last for just a single request. Conversations that span multiple requests must be demarcated using annotations provided by Seam."
msgstr "Quelques conversations perdurent dans une simple requête. Les conversations qui s’étendent sur plusieurs requêtes doivent être bien démarquées en utilisant les annotations fournies par Seam. "

#. Tag: para
#: Concepts.xml:126
#, no-c-format
msgid "Some conversations are also <emphasis>tasks</emphasis>. A task is a conversation that is significant in terms of a long-running business process, and has the potential to trigger a business process state transition when it is successfully completed. Seam provides a special set of annotations for task demarcation."
msgstr "Quelques conversations sont aussi des  <emphasis>tâches</emphasis>. une tache est une conversation ce qui a un sens en termes de processus métier à exécution longue et a le potentiel de déclencher une transition d’état pour un processus métier quand elle réussit à se terminer. Seam fournis une série d’annotations spéciales pourdifférencie cette tâche. "

#. Tag: para
#: Concepts.xml:132
#, no-c-format
msgid "Conversations may be <emphasis>nested</emphasis>, with one conversation taking place \"inside\" a wider conversation. This is an advanced feature."
msgstr "Les conversations doivent être  <emphasis>reliées</emphasis>, avec une conversation prenant sa place \"à l’intérieur\" d’une plus grande conversation. Ceci est une fonctionnalité avancée. "

#. Tag: para
#: Concepts.xml:136
#, no-c-format
msgid "Usually, conversation state is actually held by Seam in the servlet session between requests. Seam implements configurable <emphasis>conversation timeout</emphasis>, automatically destroying inactive conversations, and thus ensuring that the state held by a single user login session does not grow without bound if the user abandons conversations."
msgstr "Habituellement, l’état de la conversation est actuellement maintenu par Seam dans la session servlet entre les requêtes. Seam implémente <emphasis>un delais de péremption</emphasis> configurable, détruisant automatiquement les conversations inactives et ainsi s’assurant que l’état maintenu par une session de connexion d’un seul utilisateur ne grandi hors limitation si l’utilisateur abandonne les conversations. "

#. Tag: para
#: Concepts.xml:142
#, no-c-format
msgid "Seam serializes processing of concurrent requests that take place in the same long-running conversation context, in the same process."
msgstr "Seam sérialise les requêtes de processus concurent qui ont lieu dans le même contexte de conversation à exécution longue, dans le même processus."

#. Tag: para
#: Concepts.xml:146
#, no-c-format
msgid "Alternatively, Seam may be configured to keep conversational state in the client browser."
msgstr "Autre alternative, Seam peut être configuré pour converser l’état conversationnel dans le navigateur du client. "

#. Tag: title
#: Concepts.xml:152
#, no-c-format
msgid "<title>Session context</title>"
msgstr "<title>Le contexte de Session</title>"

#. Tag: para
#: Concepts.xml:153
#, no-c-format
msgid "A session context holds state associated with the user login session. While there are some cases where it is useful to share state between several conversations, we generally frown on the use of session context for holding components other than global information about the logged in user."
msgstr "Un contexte de session conserve un état associé avec une session de connexion utilisateur. Pour les quelques cas où il est utilise de partager l’état entre plusieurs conversation, nous libèrons habituellement l’utilisation du contexte de session pour stocker les composants autre que les informations globales à propos de la connection de l’utilisateur.. "

#. Tag: para
#: Concepts.xml:158
#, no-c-format
msgid "In a JSR-168 portal environment, the session context represents the portlet session."
msgstr "Dans l’environnement portail JSR168, le contexte de session représente la session portail. "

#. Tag: title
#: Concepts.xml:164
#, no-c-format
msgid "<title>Business process context</title>"
msgstr "<title>Le contexte de processus métier</title>"

#. Tag: para
#: Concepts.xml:165
#, no-c-format
msgid "The business process context holds state associated with the long running business process. This state is managed and made persistent by the BPM engine (JBoss jBPM). The business process spans multiple interactions with multiple users, so this state is shared between multiple users, but in a well-defined manner. The current task determines the current business process instance, and the lifecycle of the business process is defined externally using a <emphasis>process definition language</emphasis>, so there are no special annotations for business process demarcation."
msgstr "Le contexte de processus métier stocke l’état associé au processus métier à exécution longue. Cet état est géré et est rendu persistant par le moteur BMP (JBoss JBPM). Le processus métier s’étend sur de multiples interactions avec de multiples utilisateurs, donc cet état est partagé entre plusieurs utilisateurs mais de manière parfaitement définie. La tache courante détermine l’instance du processus métier courante  et le cycle de vie du processus métier est définie en externe en utilisant <emphasis>un language de définition de processus</emphasis>, donc il n’y a pas d’annotatation spéciale pour la séparation du processus métier. "

#. Tag: title
#: Concepts.xml:176
#, no-c-format
msgid "<title>Application context</title>"
msgstr "<title>Le contexte d'Application</title>"

#. Tag: para
#: Concepts.xml:177
#, no-c-format
msgid "The application context is the familiar servlet context from the servlet spec. Application context is mainly useful for holding static information such as configuration data, reference data or metamodels. For example, Seam stores its own configuration and metamodel in the application context."
msgstr "Le contexte d’application est le contexte de servlet familier de la spécification servlet. Le contexte d’application est principalement utilisé pour stocker l’information statique comme des données de configuration, des données de référence ou des méta-modèles. Par exemple, Seam stocke sa propre configuration et son méta-modèle dans le contexte d’application. "

#. Tag: title
#: Concepts.xml:185
#, no-c-format
msgid "Context variables"
msgstr "Les variables de contexte"

#. Tag: para
#: Concepts.xml:186
#, no-c-format
msgid "A context defines a namespace, a set of <emphasis>context variables</emphasis>. These work much the same as session or request attributes in the servlet spec. You may bind any value you like to a context variable, but usually we bind Seam component instances to context variables."
msgstr "Un contexte défini un espace de nom, un ensemble de <emphasis>variables de contexte</emphasis>. Ceci fonctionne à peu prêt comme des attributs de session ou de requête dans la spécification servlet. Vous devez faire correspondre n’importe quelle valeur que vous voulez à une variable de contexte, mais habituellement nous faisons correspondre les instances de composant Seam à des variables de contexte."

#. Tag: para
#: Concepts.xml:192
#, no-c-format
msgid "So, within a context, a component instance is identified by the context variable name (this is usually, but not always, the same as the component name). You may programatically access a named component instance in a particular scope via the <literal>Contexts</literal> class, which provides access to several thread-bound instances of the <literal>Context</literal> interface:"
msgstr "Donc, dans un contexte, une instance de composant est identifiée par le nom de la variable de contexte (ceci est habituellement, mais pas toujours, la même chose que le nom du composant). Vous pouvez par programmation accéder à l’instance du composant nommée dans une étendue particulière via la classe <literal>Contexts</literal>, qui fournis un accès aux différentes instances reliées par thread de l’interace <literal>Context</literal>: "

#. Tag: programlisting
#: Concepts.xml:199
#, no-c-format
msgid "<![CDATA[User user = (User) Contexts.getSessionContext().get(\"user\");]]>"
msgstr "<![CDATA[User user = (User) Contexts.getSessionContext().get(\"user\");]]>"

#. Tag: para
#: Concepts.xml:201
#, no-c-format
msgid "You may also set or change the value associated with a name:"
msgstr "Vous pouvez aussi définir ou changer la valeur associé avec son nom :"

#. Tag: programlisting
#: Concepts.xml:205
#, no-c-format
msgid "<![CDATA[Contexts.getSessionContext().set(\"user\", user);]]>"
msgstr "<![CDATA[Contexts.getSessionContext().set(\"user\", user);]]>"

#. Tag: para
#: Concepts.xml:207
#, no-c-format
msgid "Usually, however, we obtain components from a context via injection, and put component instances into a context via outjection."
msgstr "Habituellement, malgré tout, nous obtenons les composants depuis le contexte via une injection, et mettons les instances de composants dans le contexte via une extrusion."

#. Tag: title
#: Concepts.xml:214
#, no-c-format
msgid "Context search priority"
msgstr "Priorité dans la recherche de contexte"

#. Tag: para
#: Concepts.xml:215
#, no-c-format
msgid "Sometimes, as above, component instances are obtained from a particular known scope. Other times, all stateful scopes are searched, in <emphasis>priority order</emphasis>. The order is as follows:"
msgstr "Parfois, comme ci-dessus, les instances des composants sont obtenus depuis une étendue connus particulière. D’autre fois, tous les étendues avec états sont parcourues, dans un <emphasis>ordre de priorité</emphasis>. Cet ordre est indiqué ci-dessous: "

#. Tag: para
#: Concepts.xml:222
#, no-c-format
msgid "<para>Event context</para>"
msgstr "<para>Contexte d'évènement</para>"

#. Tag: para
#: Concepts.xml:241
#, no-c-format
msgid "You can perform a priority search by calling <literal>Contexts.lookupInStatefulContexts()</literal>. Whenever you access a component by name from a JSF page, a priority search occurs."
msgstr "Vous pouvez réaliser une recherche par priorité en appelant<literal>Contexts.lookupInStatefulContexts()</literal>. Malgré cela, si vous accédez a un composant par son nom depuis une page JSF, une recherche par ordre de priorité est faite."

#. Tag: title
#: Concepts.xml:249
#, no-c-format
msgid "Concurrency model"
msgstr "Modèle de concurrence"

#. Tag: para
#: Concepts.xml:250
#, no-c-format
msgid "Neither the servlet nor EJB specifications define any facilities for managing concurrent requests originating from the same client. The servlet container simply lets all threads run concurrently and leaves enforcing threadsafeness to application code. The EJB container allows stateless components to be accessed concurrently, and throws an exception if multiple threads access a stateful session bean."
msgstr "Ni les spécifications servlet ni EJB ne définissent la moindre indications pour l’organisation des requêtes originaire du même client. Le container de servlet simplement laisse tous les threards s’exécuter de manière concurrente et laisse la sureté des threads se renforcer dans le code applicatif. Le container EJB autorise les composants sans état à être accédés de manière concurrente et déclenche des exceptions si de multiples threads accèdent à un bean session avec état. "

#. Tag: para
#: Concepts.xml:256
#, no-c-format
msgid "This behavior might have been okay in old-style web applications which were based around fine-grained, synchronous requests. But for modern applications which make heavy use of many fine-grained, asynchronous (AJAX) requests, concurrency is a fact of life, and must be supported by the programming model. Seam weaves a concurrency management layer into its context model."
msgstr "Cette fonctionnalité devrait être ok dans les applications web au style ancien qui sont basées autour de requêtes bien dimensionnées et synchrones. Mais les applications modernes qui font une utilisation lourde de nombreuses requêtes bien dimensionnées et asynchrones (AJAX), de manière concurrente est un état de fait doivent être supporté par le modèle de programmation. Seam fourni une couche de gestion concurrente dans son modèle de contexte. "

#. Tag: para
#: Concepts.xml:262
#, no-c-format
msgid "The Seam session and application contexts are multithreaded. Seam will allow concurrent requests in a context to be processed concurrently. The event and page contexts are by nature single threaded. The business process context is strictly speaking multi-threaded, but in practice concurrency is sufficiently rare that this fact may be disregarded most of the time. Finally, Seam enforces a <emphasis>single thread per conversation per process</emphasis> model for the conversation context by serializing concurrent requests in the same long-running conversation context."
msgstr "La session Seam et les contextes d’application sont multi threadées. Seam va nous autoriser des requêtes concurrentes dans un contexte pouvant être exécuté en concurrence. Les contextes page et d'évènements sont par nature un simple thread. Le contexte de processus métier est strictement parlant multi threadé, mais en pratique la concurrence est suffisamment rare pour que ce fait puisse être assez peu controlé la plus part du temps. Finalement, Seam renforce le modèle <emphasis>d'un seul thread par conversation par processus</emphasis> pour le contexte de conversation en sérialisant les requêtes concurrentes dans un même contexte de conversation d’exécution longue."

#. Tag: para
#: Concepts.xml:270
#, no-c-format
msgid "Since the session context is multithreaded, and often contains volatile state, session scope components are always protected by Seam from concurrent access so long as the Seam interceptors are not disabled for that component. If interceptors are disabled, then any thread-safety that is required must be implemented by the component itself. Seam serializes requests to session scope session beans and JavaBeans by default (and detects and breaks any deadlocks that occur). This is not the default behaviour for application scoped components however, since application scoped components do not usually hold volatile state and because synchronization at the global level is <emphasis>extremely</emphasis> expensive. However, you can force a serialized threading model on any session bean or JavaBean component by adding the <literal>@Synchronized</literal> annotation."
msgstr "Depuis que le contexte de session est multi-threadé et souvent il contient un état volatile, les composants de l’étendue session sont toujours protégés par Seam d’accès concurrents aussi longtemps que les intercepteurs de Seam ne sont pas désactivés par ce composant. Si les intercepteurs sont désactivés, alors tout accès sécurisé au thread doit être implémenté par le concurent lui-même. Seam sérialise les requêtes dans les beans de session l’étendue de session et dans les JavaBeans par défaut (et détecte et brise toute étreinte mortele qui apparait). Ceci n’est pas la fonctionnalité par défaut pour les composants de l’étendue application, car les composants de l’étendue application ne conservent pas habituellement un état volatile et tout cela à cause de la synchronisation au niveau global qui est <emphasis>extrèmement</emphasis> couteuse. Malgré tout, vous pouvez forcer le modèle de threads en sérialisation sur n’imoporte quel bean session ou composant JavaBean en ajoutant l’annotation @Synchronized."

#. Tag: para
#: Concepts.xml:281
#, no-c-format
msgid "This concurrency model means that AJAX clients can safely use volatile session and conversational state, without the need for any special work on the part of the developer."
msgstr "Le modèle concurrent signifie que les clients AJAX peuvent de manière sure utiliser la session volatile et un état conversationnel, sans le besoin d’un travail particulier de la part du développeur."

#. Tag: title
#: Concepts.xml:290
#, no-c-format
msgid "Seam components"
msgstr "Les composants de Seam"

#. Tag: para
#: Concepts.xml:291
#, no-c-format
msgid "Seam components are POJOs (Plain Old Java Objects). In particular, they are JavaBeans or EJB 3.0 enterprise beans. While Seam does not require that components be EJBs and can even be used without an EJB 3.0 compliant container, Seam was designed with EJB 3.0 in mind and includes deep integration with EJB 3.0. Seam supports the following <emphasis>component types</emphasis>."
msgstr "Les composants de Seam sont ds POJOs (Plain old java Objects). En particulier, s'ils sont des JavaBeans ou bean entreprise EJB3.0. Tant que Sean ne requière pas que ces composants soient des EJBs et ainsi qu’il puisse même être utilisés sans un container compatible EJB3, Seam a été conçu avec EJB3.0 comme état d’esprit et il inclus une intégration profonde avec EJB3.0. Seam supporte les <emphasis>types de composants</emphasis> suivants. "

#. Tag: para
#: Concepts.xml:300
#, no-c-format
msgid "EJB 3.0 stateless session beans"
msgstr "Beans de session sans état EJB 3.0 "

#. Tag: para
#: Concepts.xml:303
#, no-c-format
msgid "EJB 3.0 stateful session beans"
msgstr "Beans de session avec état  EJB 3.0 "

#. Tag: para
#: Concepts.xml:306
#, no-c-format
msgid "EJB 3.0 entity beans (i.e., JPA entity classes)"
msgstr "Beans entité EJB 3.0  (autrement dit, des classes d'entité JPA)"

#. Tag: para
#: Concepts.xml:309
#, no-c-format
msgid "<para>JavaBeans</para>"
msgstr "<para>JavaBeans</para>"

#. Tag: para
#: Concepts.xml:312
#, no-c-format
msgid "EJB 3.0 message-driven beans"
msgstr "Les beans conducteur de message EJB 3.0"

#. Tag: para
#: Concepts.xml:315
#, no-c-format
msgid "Spring beans (see <xref linkend=\"spring\"/>)"
msgstr "Les beans de Spring (see <xref linkend=\"spring\"/>)"

#. Tag: title
#: Concepts.xml:320
#, no-c-format
msgid "Stateless session beans"
msgstr "Les beans de session sans état"

#. Tag: para
#: Concepts.xml:321
#, no-c-format
msgid "Stateless session bean components are not able to hold state across multiple invocations. Therefore, they usually work by operating upon the state of other components in the various Seam contexts. They may be used as JSF action listeners, but cannot provide properties to JSF components for display."
msgstr "Les composants de bean session sans état ne sont pas capables de retenir un état au travers de multiples invocations. Ainsi, ils travaillent habituellement en opérant au dessus de l’état d’autres composants dans les différents contextes de Seam. Ils peuvent être utilisés comme écouteur d’action JSF mais ne peuvent fournir une propriété à des composants JSF pour l’affichage."

#. Tag: para
#: Concepts.xml:326
#, no-c-format
msgid "Stateless session beans always live in the stateless context."
msgstr "Les beans session sans états existent toujours dans un contexte sans état. "

#. Tag: para
#: Concepts.xml:329
#, no-c-format
msgid "Stateless session beans can be accessed concurrently as a new instance is used for each request. Assigning the instance to the request is the responsibility of the EJB3 container (normally instances will be allocated from a reusable pool meaning that you may find any instance variables contain data from previous uses of the bean)."
msgstr "Les beans de session sans état peuvent être accédés de manière concurente comme une nouvelle instance qui est utilisé pour chaque requête. Assigner l'instance à une requête est de la responsabilité du containeur EJB3 (les instances normallement seront alloués depuis un groupement réutilisable ce qui signifie que vous pourriez trouver des variables d'instance contenant des données d'un utilisation précédente du bean)."

#. Tag: para
#: Concepts.xml:335
#, no-c-format
msgid "Stateless session beans are the least interesting kind of Seam component."
msgstr "Les beans session sans états sont les moins intéressants des types de composant Seam. "

#. Tag: para
#: Concepts.xml:338
#, no-c-format
msgid "Seam stateless session bean components may be instantiated using <literal>Component.getInstance()</literal> or <literal>@In(create=true)</literal>. They should not be directly instantiated via JNDI lookup or the <literal>new</literal> operator."
msgstr "Les beans session sans états peuvent être instanciés en utilisant <literal>Component.getInstance()</literal> ou <literal>@In(create=true)</literal>. Ils ne devraient pas être instanciés via l'observateur JNDI ou par l'opérateur <literal>new</literal>."

#. Tag: title
#: Concepts.xml:346
#, no-c-format
msgid "Stateful session beans"
msgstr "Les Beans de session avec état"

#. Tag: para
#: Concepts.xml:347
#, no-c-format
msgid "Stateful session bean components are able to hold state not only across multiple invocations of the bean, but also across multiple requests. Application state that does not belong in the database should usually be held by stateful session beans. This is a major difference between Seam and many other web application frameworks. Instead of sticking information about the current conversation directly in the <literal>HttpSession</literal>, you should keep it in instance variables of a stateful session bean that is bound to the conversation context. This allows Seam to manage the lifecycle of this state for you, and ensure that there are no collisions between state relating to different concurrent conversations."
msgstr "Les composants beans de session avec état sont capables de retenir un état pas seulement au travers de multiples invocations du bean mais aussi au travers de multiples requêtes. L’état de l’application ne doit pas s’attarder dans la base de données pour être éventuellement retenu par des beans de sessions avec état. Ceci est une différence principale entre Seam et d’autres serveurs d’application web. Plutôt que de coller de l’information à propos de la conversation courante directement dans le <literal>HttpSession</literal>, vous devriez conserver ces variables d’instance d’un bean session avec état qui va être relié au contexte de conversation. Ceci autorise Seam à gérer le cycle de vie de cet état pour vous et vous assure qu’il n’y aura pas de collision entre les états dans différentes conversations concurrentes."

#. Tag: para
#: Concepts.xml:357
#, no-c-format
msgid "Stateful session beans are often used as JSF action listener, and as backing beans that provide properties to JSF components for display or form submission."
msgstr "Les beans de session avec état sont souvent utilisés comme écouteur d’action JSF, et comme beans de soutient qui fournissent des propriétés aux composants JSF pour l’affichage ou la soumissions de formulaire. "

#. Tag: para
#: Concepts.xml:361
#, no-c-format
msgid "By default, stateful session beans are bound to the conversation context. They may never be bound to the page or stateless contexts."
msgstr "Par défaut, les beans de session avec état sont reliés au contexte de conversation. Ils ne peuvent jamais reliés  aux contextes de page ou sans état. "

#. Tag: para
#: Concepts.xml:365
#, no-c-format
msgid "Concurrent requests to session-scoped stateful session beans are always serialized by Seam as long as the Seam interceptors are not disabled for the bean."
msgstr "Les requêtes concurrentes pour les sessions avec état dans l’étendue de session sont toujours sérialisées par Seam si les intercepteurs de Seam ne sont pas désactivés par le bean."

#. Tag: para
#: Concepts.xml:370
#, no-c-format
msgid "Seam stateful session bean components may be instantiated using <literal>Component.getInstance()</literal> or <literal>@In(create=true)</literal>. They should not be directly instantiated via JNDI lookup or the <literal>new</literal> operator."
msgstr "Les beans session avec états peuvent être instanciés en utilisant <literal>Component.getInstance()</literal> ou <literal>@In(create=true)</literal>. Ils ne devraient pas être instanciés via l'observateur JNDI ou par l'opérateur <literal>new</literal>."

#. Tag: title
#: Concepts.xml:378
#, no-c-format
msgid "Entity beans"
msgstr "Les beans entité"

#. Tag: para
#: Concepts.xml:379
#, no-c-format
msgid "Entity beans may be bound to a context variable and function as a seam component. Because entities have a persistent identity in addition to their contextual identity, entity instances are usually bound explicitly in Java code, rather than being instantiated implicitly by Seam."
msgstr "Les beans entité peuvent être reliés à une variable de contexte et fonctionne comme un composant de Seam. Avec des entitées ayant un identité persistante en plus de leur identité contextuelle, les instance d’entité sont habituellement reliées explicitement par le code Java, plutôt qu’être instanciées implicitement par Seam. "

#. Tag: para
#: Concepts.xml:384
#, no-c-format
msgid "Entity bean components do not support bijection or context demarcation. Nor does invocation of an entity bean trigger validation."
msgstr "Les composants bean entité ne supportent pas la bijection ou la démarcation du contexte. Aucune invocation d’un bean entité ne déclenchera la validation."

#. Tag: para
#: Concepts.xml:388
#, no-c-format
msgid "Entity beans are not usually used as JSF action listeners, but do often function as backing beans that provide properties to JSF components for display or form submission. In particular, it is common to use an entity as a backing bean, together with a stateless session bean action listener to implement create/update/delete type functionality."
msgstr "Les beans entité ne sont habituellement pas utilisés comme écouteur d’action JSF, mais ont aussi la fonction d’un bean de soutient qui fourni des propriétés aux composants JSF pour l’affichage et la soumission de formulaire. En particulier, il est commun d’utiliser une entité comme un bean de soutient, avec un écouteur d’action de bean de session sans état pour implémenter les fonctionnalités de type création/mise à jour/effacement. "

#. Tag: para
#: Concepts.xml:394
#, no-c-format
msgid "By default, entity beans are bound to the conversation context. They may never be bound to the stateless context."
msgstr "Par défaut, les beans entités sont reliés au contexte de conversation. Ils ne devraient jamais être reliés au contexte sans état. "

#. Tag: para
#: Concepts.xml:398
#, no-c-format
msgid "Note that it in a clustered environment is somewhat less efficient to bind an entity bean directly to a conversation or session scoped Seam context variable than it would be to hold a reference to the entity bean in a stateful session bean. For this reason, not all Seam applications define entity beans to be Seam components."
msgstr "Notez que dans un environement en cluster il est parfois moins efficace de relier un bean entité directement à une conversation ou à une variable de contexte de Seam d'étendue de session que de maintenir une reference au bean entité dans une bean de session avec état. C'est pour cette raison que toutes les applications Seam ne définissent pas des beans entité a être des composants Seam."

#. Tag: para
#: Concepts.xml:404
#, no-c-format
msgid "Seam entity bean components may be instantiated using <literal>Component.getInstance()</literal>, <literal>@In(create=true)</literal> or directly using the <literal>new</literal> operator."
msgstr "Les composant beans entité de Seam peuvent être instanciés en utilisant <literal>Component.getInstance()</literal> ou <literal>@In(create=true)</literal> ou directement en utilisant l'opérateur <literal>new</literal>."

#. Tag: title
#: Concepts.xml:411
#, no-c-format
msgid "<title>JavaBeans</title>"
msgstr "<title>JavaBeans</title>"

#. Tag: para
#: Concepts.xml:412
#, no-c-format
msgid "Javabeans may be used just like a stateless or stateful session bean. However, they do not provide the functionality of a session bean (declarative transaction demarcation, declarative security, efficient clustered state replication, EJB 3.0 persistence, timeout methods, etc)."
msgstr "Les Javabeans devraient être utilisé tout comme un bean de session avec ou sans état. Magrè tout, ils ne fournissent pas les fonctionnalités de bean de session (démarcation de transaction déclarative, sécurité déclarative, réplication d’état en cluster efficace, peristance EJB3.0, méthode hors-delais,etc). "

#. Tag: para
#: Concepts.xml:417
#, no-c-format
msgid "In a later chapter, we show you how to use Seam and Hibernate without an EJB container. In this use case, components are JavaBeans instead of session beans. Note, however, that in many application servers it is somewhat less efficient to cluster conversation or session scoped Seam JavaBean components than it is to cluster stateful session bean components."
msgstr "Dans un chapitre suivant, nous vous montrerons comment utiliser Seam et Hibernate sans un container EJB. Dans ce cas d’utilisation, les composants sont des JavaBeans au lieu de beans de session. Notez, malgré cela, dans beaucoup de serveurs d’application il est parfois moins efficace de rassembler les conversations ou les composants JavaBeans de Seam d’étendue session que de rassembler les composants bean de session avec état."

#. Tag: para
#: Concepts.xml:423
#, no-c-format
msgid "By default, JavaBeans are bound to the event context."
msgstr "Par défaut, les JavaBeans sont reliés au contexte d’évènement. "

#. Tag: para
#: Concepts.xml:426
#, no-c-format
msgid "Concurrent requests to session-scoped JavaBeans are always serialized by Seam."
msgstr "Les requêtes concurrentes dans les Javabeans d’étendue session sont toujours sérialisées par Seam. "

#. Tag: para
#: Concepts.xml:429
#, no-c-format
msgid "Seam JavaBean components may be instantiated using <literal>Component.getInstance()</literal> or <literal>@In(create=true)</literal>. They should not be directly instantiated using the <literal>new</literal> operator."
msgstr "Les composant JavaBean de Seam peuvent être instanciés en utilisant <literal>Component.getInstance()</literal> ou <literal>@In(create=true)</literal>. Ils ne devraient jamais être instancié en utilisant l'opérateur <literal>new</literal>."

#. Tag: title
#: Concepts.xml:437
#, no-c-format
msgid "Message-driven beans"
msgstr "Les beans conducteur-de-message"

#. Tag: para
#: Concepts.xml:438
#, no-c-format
msgid "Message-driven beans may function as a seam component. However, message-driven beans are called quite differently to other Seam components - instead of invoking them via the context variable, they listen for messages sent to a JMS queue or topic."
msgstr "Les beans conducteur-de-message peuvent fonctionner comme un composant Seam. Malgrè cela, les beans  conducteur-de-message sont appeler un peu différemment des autres  composants de Seam- au lieu de les invoquer via une variable de contexte, ils écoutent les messages envoyés vers une file d’attente JMS ou un topic."

#. Tag: para
#: Concepts.xml:443
#, no-c-format
msgid "Message-driven beans may not be bound to a Seam context. Nor do they have access to the session or conversation state of their \"caller\". However, they do support bijection and some other Seam functionality."
msgstr "Les beans  conducteur-de-message peuvent ne pas être reliés à un contexte de Seam. Ils n’ont pas non plus d’accès à la session ou l’état de conversation de leur \"appelant\". Magrè cela, ils peuvent supporter la bijection et quelques autres fonctionnalités de Seam. "

#. Tag: para
#: Concepts.xml:448
#, no-c-format
msgid "Message-driven beans are never instantiated by the application. They are instantiated by the EJB container when a message is received."
msgstr "Les beans  conducteur-de-message ne sont jamais instanciés par l'application. Ils sont instanciés par le containeur EJB quand un message est reçu."

#. Tag: title
#: Concepts.xml:455
#, no-c-format
msgid "Interception"
msgstr "L'intercepteur"

#. Tag: para
#: Concepts.xml:456
#, no-c-format
msgid "In order to perform its magic (bijection, context demarcation, validation, etc), Seam must intercept component invocations. For JavaBeans, Seam is in full control of instantiation of the component, and no special configuration is needed. For entity beans, interception is not required since bijection and context demarcation are not defined. For session beans, we must register an EJB interceptor for the session bean component. We could use an annotation, as follows:"
msgstr "Pour réussir à faire sont tour de magie (bijection, démarcation de contexte, validation, etc.), Seam doit intercepter les invocations de composant. Pour les JavaBeans, Seam est un contrôleur total de l’instanciation du composant, et aucune configuration spéciale n’est requise. Pour les beans entité, l’interception n’est pas requise à moins d'une bijection et la démarcation de contexte ne sont pas défini. Pour les beans session, nous devons enregistrer un intercepteur EJB pour le composant bean de session. Nous pourrions utiliser une annotation, comme ci-dessous :"

#. Tag: programlisting
#: Concepts.xml:464
#, no-c-format
msgid ""
"<![CDATA[@Stateless\n"
"@Interceptors(SeamInterceptor.class)\n"
"public class LoginAction implements Login { \n"
"    ... \n"
"}]]>"
msgstr ""
"<![CDATA[@Stateless\n"
"@Interceptors(SeamInterceptor.class)\n"
"public class LoginAction implements Login { \n"
"    ... \n"
"}]]>"

#. Tag: para
#: Concepts.xml:466
#, no-c-format
msgid "But a much better way is to define the interceptor in <literal>ejb-jar.xml</literal>."
msgstr "Mais la meilleure façon de faire est de définir un intercepteur dans <literal>ejb-jar.xml</literal>."

#. Tag: programlisting
#: Concepts.xml:470
#, no-c-format
msgid ""
"<![CDATA[<interceptors>\n"
"   <interceptor>\n"
"      <interceptor-class>org.jboss.seam.ejb.SeamInterceptor</interceptor-class>\n"
"   </interceptor>\n"
"</interceptors>\n"
"   \n"
"<assembly-descriptor>\n"
"   <interceptor-binding>\n"
"      <ejb-name>*</ejb-name>\n"
"      <interceptor-class>org.jboss.seam.ejb.SeamInterceptor</interceptor-class>\n"
"   </interceptor-binding>\n"
"</assembly-descriptor>]]>"
msgstr ""
"<![CDATA[<interceptors>\n"
"   <interceptor>\n"
"      <interceptor-class>org.jboss.seam.ejb.SeamInterceptor</interceptor-class>\n"
"   </interceptor>\n"
"</interceptors>\n"
"   \n"
"<assembly-descriptor>\n"
"   <interceptor-binding>\n"
"      <ejb-name>*</ejb-name>\n"
"      <interceptor-class>org.jboss.seam.ejb.SeamInterceptor</interceptor-class>\n"
"   </interceptor-binding>\n"
"</assembly-descriptor>]]>"

#. Tag: title
#: Concepts.xml:475
#, no-c-format
msgid "Component names"
msgstr "Les noms de component"

#. Tag: para
#: Concepts.xml:476
#, no-c-format
msgid "All seam components need a name. We can assign a name to a component using the <literal>@Name</literal> annotation:"
msgstr "Tous les composants de Seam au besoin d’un  nom. Nous pouvons assigner un nom à un composant en utilisant l’annotation <literal>@Name</literal>:"

#. Tag: programlisting
#: Concepts.xml:481
#, no-c-format
msgid ""
"<![CDATA[@Name(\"loginAction\")\n"
"@Stateless\n"
"public class LoginAction implements Login { \n"
"    ... \n"
"}]]>"
msgstr ""
"<![CDATA[@Name(\"loginAction\")\n"
"@Stateless\n"
"public class LoginAction implements Login { \n"
"    ... \n"
"}]]>"

#. Tag: para
#: Concepts.xml:483
#, no-c-format
msgid "This name is the <emphasis>seam component name</emphasis> and is not related to any other name defined by the EJB specification. However, seam component names work just like JSF managed bean names and you can think of the two concepts as identical."
msgstr "Ce nom est un <emphasis>nom de composant seam</emphasis> et n’est pas lié a un tout autre nom défini par la spécification EJB. Malgré tout, les noms de composant Seam fonctionnent tous comme les noms des beans de gestion JSF et vous pouvez penser que les deux concepts sont identiques."

#. Tag: para
#: Concepts.xml:489
#, no-c-format
msgid "<literal>@Name</literal> is not the only way to define a component name, but we always need to specify the name <emphasis>somewhere</emphasis>. If we don't, then none of the other Seam annotations will function."
msgstr "<literal>@Name</literal> n'est pas la seule façon de définir un nom de composant, mais nous avons toujours besoin de spécifier ce nom <emphasis>quelque part</emphasis>. Si nous ne le faisons pas, alors aucune autre annotation de Seam ne va fonctionner."

#. Tag: para
#: Concepts.xml:495
#, no-c-format
msgid "Whenever Seam instantiates a component, it binds the new instance to a variable in the scope configured for the component that matches the component name. This behavior is identical to how JSF managed beans work, except that Seam allows you to configure this mapping using annotations rather than XML. You can also programmatically bind a component to a context variable. This is useful if a particular component serves more than one role in the system. For example, the currently logged in <literal>User</literal> might be bound to the <literal>currentUser</literal> session context variable, while a <literal>User</literal> that is the subject of some administration functionality might be bound to the <literal>user</literal> conversation context variable. Be careful, though, because through a programmatic assignment, it's possible to overwrite a context variable that has a reference to a Seam component, potentially confusing matters."
msgstr "A chaque fois que Seam instancie un composant, il relie cette nouvelle instance à une variable dans l'étendue configuré pour ce composant qui correspondant au nom du composant. Cette fonctionnalité est identique à comment JSF fait travailler les beans qu'il gère, exception que Seam vous permet de configurer cette relation en utilisant des annotation au lieu de XMM. Par exemple, le connecté courant dans  <literal>User</literal> peut être relié à une variable de contexte de session <literal>currentUser</literal> tant que le <literal>User</literal> dont il est sujet à quelques fonctionnalités administratives qui peuvent être reliées à la variable de contexte de conversation user. Soyez prudent, pensez-y, parce qu'au traver d'une affectation programmée, il est possible de surcharger une variable de contexte qui a une référence sur un composant de Seam, avec de potentiel problèmes de confusion."

#. Tag: para
#: Concepts.xml:506
#, no-c-format
msgid "For very large applications, and for built-in seam components, qualified component names are often used to avoid naming conflicts."
msgstr "Pour de plus grande applications, et pour les composants de Seam livrés, les noms qualifiés sont souvent utilisés. "

#. Tag: programlisting
#: Concepts.xml:511
#, no-c-format
msgid ""
"<![CDATA[@Name(\"com.jboss.myapp.loginAction\")\n"
"@Stateless\n"
"public class LoginAction implements Login { \n"
"    ... \n"
"}]]>"
msgstr ""
"<![CDATA[@Name(\"com.jboss.myapp.loginAction\")\n"
"@Stateless\n"
"public class LoginAction implements Login { \n"
"    ... \n"
"}]]>"

#. Tag: para
#: Concepts.xml:513
#, no-c-format
msgid "We may use the qualified component name both in Java code and in JSF's expression language:"
msgstr "Nous devrions utiliser le nom de composant qualifié à la fois dans le code Java et dans le langage d’expression de JSF:  "

#. Tag: programlisting
#: Concepts.xml:517
#, no-c-format
msgid ""
"<![CDATA[<h:commandButton type=\"submit\" value=\"Login\"\n"
"                 action=\"#{com.jboss.myapp.loginAction.login}\"/>]]>"
msgstr ""
"<![CDATA[<h:commandButton type=\"submit\" value=\"Login\"\n"
"                 action=\"#{com.jboss.myapp.loginAction.login}\"/>]]>"

#. Tag: para
#: Concepts.xml:519
#, no-c-format
msgid "Since this is noisy, Seam also provides a means of aliasing a qualified name to a simple name. Add a line like this to the <literal>components.xml</literal> file:"
msgstr "Comme c’est perturbant, Seam fourni aussi une manière pour renommer un nom qualifié en nom simple. Ajouter une ligne comme celle-ci dans le fichier components.xml: "

#. Tag: programlisting
#: Concepts.xml:524
#, no-c-format
msgid "<![CDATA[<factory name=\"loginAction\" scope=\"STATELESS\" value=\"#{com.jboss.myapp.loginAction}\"/>]]>"
msgstr "<![CDATA[<factory name=\"loginAction\" scope=\"STATELESS\" value=\"#{com.jboss.myapp.loginAction}\"/>]]>"

#. Tag: para
#: Concepts.xml:526
#, no-c-format
msgid "All of the built-in Seam components have qualified names but can be accessed through their unqualified names due to the namespace import feature of Seam. The <literal>components.xml</literal> file included in the Seam JAR defines the following namespaces."
msgstr "Tous les composants Seam livrés ont un nom qualifié, mais la plus part d’entre eux sont renommés vers un nom simple grâce à la fonctionnalité d'importation de l'espace de nommage de Seam. Le fichier <literal>components.xml</literal>  inclus dans le JAR de Seam définie les espaces de nommage suivant."

#. Tag: programlisting
#: Concepts.xml:533
#, no-c-format
msgid ""
"&lt;components xmlns=&quot;http://jboss.com/products/seam/components&quot;&gt;\n"
"    \n"
"    &lt;import&gt;org.jboss.seam.core&lt;/import&gt;\n"
"    &lt;import&gt;org.jboss.seam.cache&lt;/import&gt;\n"
"    &lt;import&gt;org.jboss.seam.transaction&lt;/import&gt;\n"
"    &lt;import&gt;org.jboss.seam.framework&lt;/import&gt;\n"
"    &lt;import&gt;org.jboss.seam.web&lt;/import&gt;\n"
"    &lt;import&gt;org.jboss.seam.faces&lt;/import&gt;\n"
"    &lt;import&gt;org.jboss.seam.international&lt;/import&gt;\n"
"    &lt;import&gt;org.jboss.seam.theme&lt;/import&gt;\n"
"    &lt;import&gt;org.jboss.seam.pageflow&lt;/import&gt;\n"
"    &lt;import&gt;org.jboss.seam.bpm&lt;/import&gt;\n"
"    &lt;import&gt;org.jboss.seam.jms&lt;/import&gt;\n"
"    &lt;import&gt;org.jboss.seam.mail&lt;/import&gt;\n"
"    &lt;import&gt;org.jboss.seam.security&lt;/import&gt;\n"
"    &lt;import&gt;org.jboss.seam.security.management&lt;/import&gt;  \n"
"    &lt;import&gt;org.jboss.seam.security.permission&lt;/import&gt;\n"
"    &lt;import&gt;org.jboss.seam.captcha&lt;/import&gt;\n"
"    &lt;import&gt;org.jboss.seam.excel.exporter&lt;/import&gt;\n"
"    &lt;!-- ... ---&gt;\n"
"&lt;/components&gt;"
msgstr ""
"&lt;components xmlns=&quot;http://jboss.com/products/seam/components&quot;&gt;\n"
"    \n"
"    &lt;import&gt;org.jboss.seam.core&lt;/import&gt;\n"
"    &lt;import&gt;org.jboss.seam.cache&lt;/import&gt;\n"
"    &lt;import&gt;org.jboss.seam.transaction&lt;/import&gt;\n"
"    &lt;import&gt;org.jboss.seam.framework&lt;/import&gt;\n"
"    &lt;import&gt;org.jboss.seam.web&lt;/import&gt;\n"
"    &lt;import&gt;org.jboss.seam.faces&lt;/import&gt;\n"
"    &lt;import&gt;org.jboss.seam.international&lt;/import&gt;\n"
"    &lt;import&gt;org.jboss.seam.theme&lt;/import&gt;\n"
"    &lt;import&gt;org.jboss.seam.pageflow&lt;/import&gt;\n"
"    &lt;import&gt;org.jboss.seam.bpm&lt;/import&gt;\n"
"    &lt;import&gt;org.jboss.seam.jms&lt;/import&gt;\n"
"    &lt;import&gt;org.jboss.seam.mail&lt;/import&gt;\n"
"    &lt;import&gt;org.jboss.seam.security&lt;/import&gt;\n"
"    &lt;import&gt;org.jboss.seam.security.management&lt;/import&gt;  \n"
"    &lt;import&gt;org.jboss.seam.security.permission&lt;/import&gt;\n"
"    &lt;import&gt;org.jboss.seam.captcha&lt;/import&gt;\n"
"    &lt;import&gt;org.jboss.seam.excel.exporter&lt;/import&gt;\n"
"    &lt;!-- ... ---&gt;\n"
"&lt;/components&gt;"

#. Tag: para
#: Concepts.xml:535
#, no-c-format
msgid "When attempting to resolve an unqualified name, Seam will check each of those namespaces, in order. You can include additional namespaces in your application's <literal>components.xml</literal> file for application-specific namespaces."
msgstr "Pour essayer de résoudre un nom non-qualifié, Seam va vérifier chacun de ces espace de nommage, dans l'odre. Vous pouvez inclure des espaces de nommages additionnels dans votre fichier <literal>components.xml</literal> de votre application pour des espaces de nommages spécifiques à votre application."

#. Tag: title
#: Concepts.xml:543
#, no-c-format
msgid "Defining the component scope"
msgstr "Définition de l'étendue de composant"

#. Tag: para
#: Concepts.xml:544
#, no-c-format
msgid "We can override the default scope (context) of a component using the <literal>@Scope</literal> annotation. This lets us define what context a component instance is bound to, when it is instantiated by Seam."
msgstr "Nous pouvons surchargé létendue par défaut (le contexte) d’un composant en utilisation l’annotation <literal>@Scope</literal>.Ceci nous permets de définir quel contexte une instance de composant est relié à, quand il est instancié par Seam. "

#. Tag: programlisting
#: Concepts.xml:550
#, no-c-format
msgid ""
"<![CDATA[@Name(\"user\")\n"
"@Entity\n"
"@Scope(SESSION)\n"
"public class User { \n"
"    ... \n"
"}]]>"
msgstr ""
"<![CDATA[@Name(\"user\")\n"
"@Entity\n"
"@Scope(SESSION)\n"
"public class User { \n"
"    ... \n"
"}]]>"

#. Tag: para
#: Concepts.xml:552
#, no-c-format
msgid "<literal>org.jboss.seam.ScopeType</literal> defines an enumeration of possible scopes."
msgstr "<literal>org.jboss.seam.ScopeType</literal> defini une énumération des étendues possibles. "

#. Tag: title
#: Concepts.xml:559
#, no-c-format
msgid "Components with multiple roles"
msgstr "Les composants avec des rôles multiples"

#. Tag: para
#: Concepts.xml:560
#, no-c-format
msgid "Some Seam component classes can fulfill more than one role in the system. For example, we often have a <literal>User</literal> class which is usually used as a session-scoped component representing the current user but is used in user administration screens as a conversation-scoped component. The <literal>@Role</literal> annotation lets us define an additional named role for a component, with a different scope &#8212; it lets us bind the same component class to different context variables. (Any Seam component <emphasis>instance</emphasis> may be bound to multiple context variables, but this lets us do it at the class level, and take advantage of auto-instantiation.)"
msgstr "Des classes de composants Seam peuvent être utilisées avec plus d’un rôle dans le système. Par exemple, nous avons souvent une classe <literal>User</literal>qui est habituellement utilisée comme un composant d’étendue de session représentant l’utilisateur courant mais elle est aussi utilisée dans les écrans de l’administration de l’utilisateur comme un composant d’étendue de conversation. L’annotation <literal>@Role</literal> nous permet de définir un rôle avec un nom additionnel, avec une étendue différente  &#8212;  il nous laisse relier la même classe de composant dans des variables de contextes différentes. (Toute <emphasis>iinstance</emphasis>i de composant Seam peut être reliée à de multiples variables de contexte, mais cela nous laisse le faire au niveau classe et d'avoir l’avantage d’une auto instanciation.) "

#. Tag: programlisting
#: Concepts.xml:570
#, no-c-format
msgid ""
"<![CDATA[@Name(\"user\")\n"
"@Entity\n"
"@Scope(CONVERSATION)\n"
"@Role(name=\"currentUser\", scope=SESSION)\n"
"public class User { \n"
"    ... \n"
"}]]>"
msgstr ""
"<![CDATA[@Name(\"user\")\n"
"@Entity\n"
"@Scope(CONVERSATION)\n"
"@Role(name=\"currentUser\", scope=SESSION)\n"
"public class User { \n"
"    ... \n"
"}]]>"

#. Tag: para
#: Concepts.xml:572
#, no-c-format
msgid "The <literal>@Roles</literal> annotation lets us specify as many additional roles as we like."
msgstr "L'annotation <literal>@Roles</literal> nous permet de spécifier autant de rôles additionnels que nous voulons."

#. Tag: programlisting
#: Concepts.xml:576
#, no-c-format
msgid ""
"<![CDATA[@Name(\"user\")\n"
"@Entity\n"
"@Scope(CONVERSATION)\n"
"@Roles({@Role(name=\"currentUser\", scope=SESSION),\n"
"        @Role(name=\"tempUser\", scope=EVENT)})\n"
"public class User { \n"
"    ... \n"
"}]]>"
msgstr ""
" <![CDATA[@Name(\"user\")\n"
"@Entity\n"
"@Scope(CONVERSATION)\n"
"@Roles({@Role(name=\"currentUser\", scope=SESSION),\n"
"        @Role(name=\"tempUser\", scope=EVENT)})\n"
"public class User { \n"
"    ... \n"
"}]]>"

#. Tag: title
#: Concepts.xml:581
#, no-c-format
msgid "Built-in components"
msgstr "Les composants livrés"

#. Tag: para
#: Concepts.xml:582
#, no-c-format
msgid "Like many good frameworks, Seam eats its own dogfood and is implemented mostly as a set of built-in Seam interceptors (see later) and Seam components. This makes it easy for applications to interact with built-in components at runtime or even customize the basic functionality of Seam by replacing the built-in components with custom implementations. The built-in components are defined in the Seam namespace <literal>org.jboss.seam.core</literal> and the Java package of the same name."
msgstr "Tout comme beaucoup de bon serveur d’application, Seam mange sa propre nourriture et il implémente un série d’intercepteurs livrés (voir ci-dessous) et de composants de Seam. Ceci rend plus facile pour les applications d'interagir avec les composants livrés à l’exécution ou même de personnaliser les fonctionnalités de base de Seam en remplaçant les composants livrés avec des implémentations personnalisées. Les composants livrés sont défini dans l’espace de nommage de <literal>org.jboss.seam.core</literal> et le paquet Java du même nom. "

#. Tag: para
#: Concepts.xml:589
#, no-c-format
msgid "The built-in components may be injected, just like any Seam components, but they also provide convenient static <literal>instance()</literal> methods:"
msgstr "Les composants livrés peuvent être injectés, tout comme des composants Seam, mais ils fournissent aussi des méthodes <literal> instance()</literal> pratiques statiques: "

#. Tag: programlisting
#: Concepts.xml:593
#, no-c-format
msgid "<![CDATA[FacesMessages.instance().add(\"Welcome back, #{user.name}!\");]]>"
msgstr "<![CDATA[FacesMessages.instance().add(\"Welcome back, #{user.name}!\");]]>"

#. Tag: title
#: Concepts.xml:599
#, no-c-format
msgid "Bijection"
msgstr "La bijection"

#. Tag: para
#: Concepts.xml:600
#, no-c-format
msgid "<emphasis>Dependency injection</emphasis> or <emphasis>inversion of control</emphasis> is by now a familiar concept to most Java developers. Dependency injection allows a component to obtain a reference to another component by having the container \"inject\" the other component to a setter method or instance variable. In all dependency injection implementations that we have seen, injection occurs when the component is constructed, and the reference does not subsequently change for the lifetime of the component instance. For stateless components, this is reasonable. From the point of view of a client, all instances of a particular stateless component are interchangeable. On the other hand, Seam emphasizes the use of stateful components. So traditional dependency injection is no longer a very useful construct. Seam introduces the notion of <emphasis>bijection</emphasis> as a generalization of injection. In contrast to injection, bijection is:"
msgstr "<emphasis>L'injection de dépendance</emphasis> ou <emphasis>l'inversion de contrôle</emphasis> est maintenant un concept familier pour la plus part des développeurs Java. L’injection de dépendance permet à un composant d'obtenir une référence sur un autre composant en passant par le containeurs qui \"injecte\" l'autre composant par une méthode assesseur ou par une variable d'instance. Dans toutes les implémentations d’injection de dépendances que nous avons vu, l’injection intervient quand le composant est construit, et la référence ne change pas postérieurement pour le cycle de vie de l’instance du composant. Pour les composants sans état, ceci est raisonnable. Du point de vue d’un client, toutes les instances d’un composant sans état particulier sont interchangeables. Dans un autre côté, Seam accentue l’utilisation de composants avec état. Donc l’injection de dépendance traditionnelle n’est plus une construction vraiment utilisable. Seam introduit la notion de <emphasis>bijection</emphasis> comme une généralisation de l’injection. A la différence de l’injection, la bijection est :"

#. Tag: para
#: Concepts.xml:614
#, no-c-format
msgid "<emphasis>contextual</emphasis> - bijection is used to assemble stateful components from various different contexts (a component from a \"wider\" context may even have a reference to a component from a \"narrower\" context)"
msgstr "<emphasis>contextuelle</emphasis> - la bijection est utilisé pour assembler les composants avec état depuis plusieurs contextes différents (un composant d’un contexte \"évasé\" peut même contenir une référence sur un composant d’un contexte \"étroit\")"

#. Tag: para
#: Concepts.xml:621
#, no-c-format
msgid "<emphasis>bidirectional</emphasis> - values are injected from context variables into attributes of the component being invoked, and also <emphasis>outjected</emphasis> from the component attributes back out to the context, allowing the component being invoked to manipulate the values of contextual variables simply by setting its own instance variables"
msgstr "<emphasis>bidirectionelle</emphasis> - les valeurs sont injectées depuis les variables de contexte dans des attributs du composant qui a été invoqués et aussi <emphasis>extradé</emphasis> depuis les attributs du  composant en retour vers le contexte, autorisant le composant à être invoqué pour manipuler les valeurs des variables contextuelles simplement en définissant ces propres variables d’instances "

#. Tag: para
#: Concepts.xml:629
#, no-c-format
msgid "<emphasis>dynamic</emphasis> - since the value of contextual variables changes over time, and since Seam components are stateful, bijection takes place every time a component is invoked"
msgstr "<emphasis>dynamique</emphasis> - avec une valeur des variables contextuelles changeante au cours du temps et avec des composants Seam qui sont avec état, la bijection a lieu à chaque fois qu’un composant est invoqué"

#. Tag: para
#: Concepts.xml:636
#, no-c-format
msgid "In essence, bijection lets you alias a context variable to a component instance variable, by specifying that the value of the instance variable is injected, outjected, or both. Of course, we use annotations to enable bijection."
msgstr "Par essence, la bijection vous permet de renommer une variables de contexte dans une variables d’instance de composant en spécifiant que la valeur de la variable d’instance est injectée, extradée ou les deux. Bien sûr, nous utilisons des annotation pour activer la bijection."

#. Tag: para
#: Concepts.xml:642
#, no-c-format
msgid "The <literal>@In</literal> annotation specifies that a value should be injected, either into an instance variable:"
msgstr "L'annotation <literal>@In</literal> indique que la valeur devrait être injectée, aussi dans une variable d’instance. "

#. Tag: programlisting
#: Concepts.xml:647
#, no-c-format
msgid ""
"<![CDATA[@Name(\"loginAction\")\n"
"@Stateless\n"
"public class LoginAction implements Login { \n"
"    @In User user;\n"
"    ... \n"
"}]]>"
msgstr ""
"<![CDATA[@Name(\"loginAction\")\n"
"@Stateless\n"
"public class LoginAction implements Login { \n"
"    @In User user;\n"
"    ... \n"
"}]]>"

#. Tag: para
#: Concepts.xml:649
#, no-c-format
msgid "or into a setter method:"
msgstr "ou dans une méthode assesseur : "

#. Tag: programlisting
#: Concepts.xml:653
#, no-c-format
msgid ""
"<![CDATA[@Name(\"loginAction\")\n"
"@Stateless\n"
"public class LoginAction implements Login { \n"
"    User user;\n"
"    \n"
"    @In\n"
"    public void setUser(User user) {\n"
"        this.user=user;\n"
"    }\n"
"    \n"
"    ... \n"
"}]]>"
msgstr ""
"<![CDATA[@Name(\"loginAction\")\n"
"@Stateless\n"
"public class LoginAction implements Login { \n"
"    User user;\n"
"    \n"
"    @In\n"
"    public void setUser(User user) {\n"
"        this.user=user;\n"
"    }\n"
"    \n"
"    ... \n"
"}]]>"

#. Tag: para
#: Concepts.xml:656
#, no-c-format
msgid "By default, Seam will do a priority search of all contexts, using the name of the property or instance variable that is being injected. You may wish to specify the context variable name explicitly, using, for example, <literal>@In(\"currentUser\")</literal>."
msgstr "Par défaut, Seam va donner une priorité de recherche dans tous les contextes en utilisant le nom de la propriété ou de la variable d’instance qui a été injectée. Vous devriez vouloir spécifier le nom de la variable de contexte explicitement, en utilisant, par exemple, <literal>@In(\"currentUser\")</literal>."

#. Tag: para
#: Concepts.xml:662
#, no-c-format
msgid "If you want Seam to create an instance of the component when there is no existing component instance bound to the named context variable, you should specify <literal>@In(create=true)</literal>. If the value is optional (it can be null), specify <literal>@In(required=false)</literal>."
msgstr "Si vous voulez que Seam puisse créer une instance du composant quand il n’y a pas d’instance de composant existante reliée à une variable de contexte nommée, vous pouvez spécifier <literal>@In(create=true)</literal>. Si la valeur est optionnel (elle peut être null) spécifiez <literal>@In(required=false)</literal>."

#. Tag: para
#: Concepts.xml:668
#, no-c-format
msgid "For some components, it can be repetitive to have to specify <literal>@In(create=true)</literal> everywhere they are used. In such cases, you can annotate the component <literal>@AutoCreate</literal>, and then it will always be created, whenever needed, even without the explicit use of <literal>create=true</literal>."
msgstr "Pour quelques composants, il peut être répétitif d’avoir à spécifier <literal>@In(create=true)</literal> partout où ils sont utilisés . Dans ce genre de cas, vous pouvez annoter le composant <literal>@AutoCreate</literal>, et alors il va toujours être créé, n’important quand, même sans l’utilisation explicite de  <literal>create=true</literal>."

#. Tag: para
#: Concepts.xml:674
#, no-c-format
msgid "You can even inject the value of an expression:"
msgstr "Vous pouvez même injecter la valeur d’une expression : "

#. Tag: programlisting
#: Concepts.xml:678
#, no-c-format
msgid ""
"<![CDATA[@Name(\"loginAction\")\n"
"@Stateless\n"
"public class LoginAction implements Login { \n"
"    @In(\"#{user.username}\") String username;\n"
"    ... \n"
"}]]>"
msgstr ""
"<![CDATA[@Name(\"loginAction\")\n"
"@Stateless\n"
"public class LoginAction implements Login { \n"
"    @In(\"#{user.username}\") String username;\n"
"    ... \n"
"}]]>"

#. Tag: para
#: Concepts.xml:680
#, no-c-format
msgid "Injected values are disinjected (i.e., set to <literal>null</literal>) immediately after method completion and outjection."
msgstr "Les valeurs injectées sont désalouées (autrement dit, définie à <literal>null</literal>) immédiatement après la réalisation de la méthode et sont extraction."

#. Tag: para
#: Concepts.xml:685
#, no-c-format
msgid "(There is much more information about component lifecycle and injection in the next chapter.)"
msgstr "(Il y a beaucoup plus d'information sur le cicle de vie d'un composant et l'injection dans le chapitre suivant)."

#. Tag: para
#: Concepts.xml:689
#, no-c-format
msgid "The <literal>@Out</literal> annotation specifies that an attribute should be outjected, either from an instance variable:"
msgstr "L'annotation <literal>@Out</literal> indique qu'un attribue devrait être extradé, tout comme une variable d'instance:"

#. Tag: programlisting
#: Concepts.xml:694
#, no-c-format
msgid ""
"<![CDATA[@Name(\"loginAction\")\n"
"@Stateless\n"
"public class LoginAction implements Login { \n"
"    @Out User user;\n"
"    ... \n"
"}]]>"
msgstr ""
"<![CDATA[@Name(\"loginAction\")\n"
"@Stateless\n"
"public class LoginAction implements Login { \n"
"    @Out User user;\n"
"    ... \n"
"}]]>"

#. Tag: para
#: Concepts.xml:696
#, no-c-format
msgid "or from a getter method:"
msgstr "ou comme une méthode assesseur:"

#. Tag: programlisting
#: Concepts.xml:700
#, no-c-format
msgid ""
"<![CDATA[@Name(\"loginAction\")\n"
"@Stateless\n"
"public class LoginAction implements Login { \n"
"    User user;\n"
"    \n"
"    @Out\n"
"    public User getUser() {\n"
"        return user;\n"
"    }\n"
"    \n"
"    ... \n"
"}]]>"
msgstr ""
"<![CDATA[@Name(\"loginAction\")\n"
"@Stateless\n"
"public class LoginAction implements Login { \n"
"    User user;\n"
"    \n"
"    @Out\n"
"    public User getUser() {\n"
"        return user;\n"
"    }\n"
"    \n"
"    ... \n"
"}]]>"

#. Tag: para
#: Concepts.xml:702
#, no-c-format
msgid "An attribute may be both injected and outjected:"
msgstr "Un attribut peut être à la fois injecté et extradé:"

#. Tag: programlisting
#: Concepts.xml:706
#, no-c-format
msgid ""
"<![CDATA[@Name(\"loginAction\")\n"
"@Stateless\n"
"public class LoginAction implements Login { \n"
"    @In @Out User user;\n"
"    ... \n"
"}]]>"
msgstr ""
"<![CDATA[@Name(\"loginAction\")\n"
"@Stateless\n"
"public class LoginAction implements Login { \n"
"    @In @Out User user;\n"
"    ... \n"
"}]]>"

#. Tag: para
#: Concepts.xml:708
#, no-c-format
msgid "<para>or:</para>"
msgstr "<para>ou:</para>"

#. Tag: programlisting
#: Concepts.xml:712
#, no-c-format
msgid ""
"<![CDATA[@Name(\"loginAction\")\n"
"@Stateless\n"
"public class LoginAction implements Login { \n"
"    User user;\n"
"    \n"
"    @In\n"
"    public void setUser(User user) {\n"
"        this.user=user;\n"
"    }\n"
"    \n"
"    @Out\n"
"    public User getUser() {\n"
"        return user;\n"
"    }\n"
"    \n"
"    ... \n"
"}]]>"
msgstr ""
"<![CDATA[@Name(\"loginAction\")\n"
"@Stateless\n"
"public class LoginAction implements Login { \n"
"    User user;\n"
"    \n"
"    @In\n"
"    public void setUser(User user) {\n"
"        this.user=user;\n"
"    }\n"
"    \n"
"    @Out\n"
"    public User getUser() {\n"
"        return user;\n"
"    }\n"
"    \n"
"    ... \n"
"}]]>"

#. Tag: title
#: Concepts.xml:717
#, no-c-format
msgid "Lifecycle methods"
msgstr "Les méthode du cycle de vie"

#. Tag: para
#: Concepts.xml:719
#, no-c-format
msgid "Session bean and entity bean Seam components support all the usual EJB 3.0 lifecycle callback (<literal>@PostConstruct</literal>, <literal>@PreDestroy</literal>, etc). But Seam also supports the use of any of these callbacks with JavaBean components. However, since these annotations are not available in a J2EE environment, Seam defines two additional component lifecycle callbacks, equivalent to <literal>@PostConstruct</literal> and <literal>@PreDestroy</literal>."
msgstr "Le bean de session et les composants Seam de bean entité supportent tous les rappels du cycle de vie EJB3.0 usuel (<literal>@PostConstruct</literal>, <literal>@PreDestroy</literal>, etc). Mais Seam étend tous ces rappels aux composant JavaBean. Cependant tant que ces annotation ne sont pas disponible dans un environement J2EE, Seam défini deux composants additionnel pour le rappel dans le cycle de vie, équivalent à <literal>@PostConstruct</literal> et à <literal>@PreDestroy</literal>."

#. Tag: para
#: Concepts.xml:727
#, no-c-format
msgid "The <literal>@Create</literal> method is called after Seam instantiates a component. Components may define only one <literal>@Create</literal> method."
msgstr "La méthode <literal>@Create</literal> est appelée après que Seam instancie un composant. Les composants ne peuvent définir seulement qu'une seule méthode <literal>@Create</literal>."

#. Tag: para
#: Concepts.xml:732
#, no-c-format
msgid "The <literal>@Destroy</literal> method is called when the context that the Seam component is bound to ends. Components may define only one <literal>@Destroy</literal> method."
msgstr "La méthode <literal>@Destroy</literal> est appelé quand le contexte qui lie le composant de Seam se termine. Les composants ne peuvent définir qu'une seule méthode <literal>@Destroy</literal>."

#. Tag: para
#: Concepts.xml:737
#, no-c-format
msgid "In addition, stateful session bean components <emphasis>must</emphasis> define a method with no parameters annotated <literal>@Remove</literal>. This method is called by Seam when the context ends."
msgstr "De plus, les composants bean avec état <emphasis>doivent</emphasis> définir une méthode sans aucun paramètre annotée <literal>@Remove</literal>. Cette méthode est appelé par Seam quand le contexte se termine."

#. Tag: para
#: Concepts.xml:742
#, no-c-format
msgid "Finally, a related annotation is the <literal>@Startup</literal> annotation, which may be applied to any application or session scoped component. The <literal>@Startup</literal> annotation tells Seam to instantiate the component immediately, when the context begins, instead of waiting until it is first referenced by a client. It is possible to control the order of instantiation of startup components by specifying <literal>@Startup(depends={....})</literal>."
msgstr "Finalement, une annotation liée est l’annotation <literal>@Startup</literal> qui peut être appliquée à toutes l’application ou un composant d’étendue session. L’annotation <literal>@Startup</literal> indique à Seam d’instancier le composant immédiatement, quand le contexte commence, au lieu d’attendre avant son premier référencement par un client. Il est possible de controler l’ordre d’instanciation du démarrage des composants en spécifiant <literal>@Startup(depends={....})</literal>."

#. Tag: title
#: Concepts.xml:753
#, no-c-format
msgid "Conditional installation"
msgstr "Installation conditionelle"

#. Tag: para
#: Concepts.xml:755
#, no-c-format
msgid "The <literal>@Install</literal> annotation lets you control conditional installation of components that are required in some deployment scenarios and not in others. This is useful if:"
msgstr "L'annotation <literal>@Install</literal> vous permet de contrôler l’installation conditionnelle du composant qui sont requis dans certains scénarios de déploiement et pas dans d’autres. C'est utile si : "

#. Tag: para
#: Concepts.xml:762
#, no-c-format
msgid "You want to mock out some infrastructural component in tests."
msgstr "Vous voulez singer quelques composants d’infrastructure dans des tests. "

#. Tag: para
#: Concepts.xml:767
#, no-c-format
msgid "You want change the implementation of a component in certain deployment scenarios."
msgstr "Vous voulez modifier l’implémentation d’un composant dans certains scénarios de déploiement. "

#. Tag: para
#: Concepts.xml:773
#, no-c-format
msgid "You want to install some components only if their dependencies are available (useful for framework authors)."
msgstr "Vous voulez installer quelques composants seulement si leurs dépendances sont disponibles (utile pour les auteurs des serveur d’applications). "

#. Tag: para
#: Concepts.xml:780
#, no-c-format
msgid "<literal>@Install</literal> works by letting you specify <emphasis>precedence</emphasis> and <emphasis>dependencies</emphasis>."
msgstr "<literal>@Install</literal> fonctionne en vous laissant spécifier la <emphasis>précédence</emphasis> et les <emphasis>dépendances</emphasis>."

#. Tag: para
#: Concepts.xml:785
#, no-c-format
msgid "The precedence of a component is a number that Seam uses to decide which component to install when there are multiple classes with the same component name in the classpath. Seam will choose the component with the higher precendence. There are some predefined precedence values (in ascending order):"
msgstr "La précédence d’un composant est un numéro que Seam utilise pour décider quel composant est à installer quand il a plusieurs classes avec le même nom de composant dans le classpath. Seam va choisir le composant avec la précédence la plus haute. Il y a quelques valeurs de précédences prédéfinie (dans l’ordre ascendant) : "

#. Tag: para
#: Concepts.xml:794
#, no-c-format
msgid "<literal>BUILT_IN</literal> &#8212; the lowest precedece components are the components built in to Seam."
msgstr "<literal>BUILT_IN</literal> &#8212; les composants de précédence la plus faible sont les composants livrés avec Seam. "

#. Tag: para
#: Concepts.xml:800
#, no-c-format
msgid "<literal>FRAMEWORK</literal> &#8212; components defined by third-party frameworks may override built-in components, but are overridden by application components."
msgstr "<literal>FRAMEWORK</literal> &#8212; les composants définis par un serveur d’application tierces peuvent surcharger les composants livrés, mais ils sont surchargés par les composants d’application. "

#. Tag: para
#: Concepts.xml:807
#, no-c-format
msgid "<literal>APPLICATION</literal> &#8212; the default precedence. This is appropriate for most application components."
msgstr "<literal>APPLICATION</literal> &#8212; la précédence par défaut. C'est la valeurappropriée pour la plus part des composants d’application."

#. Tag: para
#: Concepts.xml:813
#, no-c-format
msgid "<literal>DEPLOYMENT</literal> &#8212; for application components which are deployment-specific."
msgstr "<literal>DEPLOYMENT</literal> &#8212; pour les composants d’application qui ont un déploiement spécifique."

#. Tag: para
#: Concepts.xml:819
#, no-c-format
msgid "<literal>MOCK</literal> &#8212; for mock objects used in testing."
msgstr "<literal>MOCK</literal> &#8212; pour les objets singeant qui sont utilisés en test. "

#. Tag: para
#: Concepts.xml:825
#, no-c-format
msgid "Suppose we have a component named <literal>messageSender</literal> that talks to a JMS queue."
msgstr "Supposez que nous avons un composant appelé  <literal>messageSender</literal>  qui parle à la queue de JMS."

#. Tag: programlisting
#: Concepts.xml:830
#, no-c-format
msgid ""
"<![CDATA[@Name(\"messageSender\") \n"
"public class MessageSender {\n"
"    public void sendMessage() {\n"
"        //do something with JMS\n"
"    }\n"
"}]]>"
msgstr ""
"<![CDATA[@Name(\"messageSender\") \n"
"public class MessageSender {\n"
"    public void sendMessage() {\n"
"        //do something with JMS\n"
"    }\n"
"}]]>"

#. Tag: para
#: Concepts.xml:832
#, no-c-format
msgid "In our unit tests, we don't have a JMS queue available, so we would like to stub out this method. We'll create a <emphasis>mock</emphasis> component that exists in the classpath when unit tests are running, but is never deployed with the application:"
msgstr "Si dans vos tests unitaires, nous n’avons pas de queue de JMS disponible, mais que nous aimerions simuler cette méthode. Nous allons créer un composant le <emphasis>singeant</emphasis> et qui existe dans le classpath quand les tests unitaires sont exécutés mais il n’est jamais déployé avec l’application: "

#. Tag: programlisting
#: Concepts.xml:839
#, no-c-format
msgid ""
"<![CDATA[@Name(\"messageSender\") \n"
"@Install(precedence=MOCK)\n"
"public class MockMessageSender extends MessageSender {\n"
"    public void sendMessage() {\n"
"        //do nothing!\n"
"    }\n"
"}]]>"
msgstr ""
"<![CDATA[@Name(\"messageSender\") \n"
"@Install(precedence=MOCK)\n"
"public class MockMessageSender extends MessageSender {\n"
"    public void sendMessage() {\n"
"        //do nothing!\n"
"    }\n"
"}]]>"

#. Tag: para
#: Concepts.xml:841
#, no-c-format
msgid "The <literal>precedence</literal> helps Seam decide which version to use when it finds both components in the classpath."
msgstr "La <literal>precedence</literal> aide Seam à décider quel version à utiliser quand il trouve deux composants dans la classpath. "

#. Tag: para
#: Concepts.xml:846
#, no-c-format
msgid "This is nice if we are able to control exactly which classes are in the classpath. But if I'm writing a reusable framework with many dependecies, I don't want to have to break that framework across many jars. I want to be able to decide which components to install depending upon what other components are installed, and upon what classes are available in the classpath. The <literal>@Install</literal> annotation also controls this functionality. Seam uses this mechanism internally to enable conditional installation of many of the built-in components. However, you probably won't need to use it in your application."
msgstr "C’est bien si vous étiez capable de contrôler exactement quelles classes sont dans le classpath. Mais si j’ai écrit un serveur d’application réutilisable avec beaucoup de dépendances, je ne veux pas à avoir à briser ce serveur d’applications au travers de nombreux jars. Je veux d’être capable de décider quel composants sont à installer selon quel autres composants sont déjà installés et selon quelles classes sont disponibles dans le classpath. L’annotation <literal>@Install</literal> contrôle aussi cette fonctionnalité. Seam utilise ce mécanisme interne pour activer l’installation conditionnelle de beaucoup des composants livrés. Malgré tout, vous n’aurez probablement pas besoin de l’utiliser dans votre application."

#. Tag: title
#: Concepts.xml:860
#, no-c-format
msgid "Logging"
msgstr "Mettre des traces"

#. Tag: para
#: Concepts.xml:862
#, no-c-format
msgid "Who is not totally fed up with seeing noisy code like this?"
msgstr "Qui n’en n’a pas assez de voir du code aussi touffu que celui-ci ? "

#. Tag: programlisting
#: Concepts.xml:866
#, no-c-format
msgid ""
"<![CDATA[private static final Log log = LogFactory.getLog(CreateOrderAction.class);\n"
"        \n"
"public Order createOrder(User user, Product product, int quantity) {\n"
"    if ( log.isDebugEnabled() ) {\n"
"        log.debug(\"Creating new order for user: \" + user.username() + \n"
"            \" product: \" + product.name() \n"
"            + \" quantity: \" + quantity);\n"
"    }\n"
"    return new Order(user, product, quantity);\n"
"}]]>"
msgstr ""
"<![CDATA[private static final Log log = LogFactory.getLog(CreateOrderAction.class);\n"
"        \n"
"public Order createOrder(User user, Product product, int quantity) {\n"
"    if ( log.isDebugEnabled() ) {\n"
"        log.debug(\"Creating new order for user: \" + user.username() + \n"
"            \" product: \" + product.name() \n"
"            + \" quantity: \" + quantity);\n"
"    }\n"
"    return new Order(user, product, quantity);\n"
"}]]>"

#. Tag: para
#: Concepts.xml:868
#, no-c-format
msgid "It is difficult to imagine how the code for a simple log message could possibly be more verbose. There is more lines of code tied up in logging than in the actual business logic! I remain totally astonished that the Java community has not come up with anything better in 10 years."
msgstr "Il est difficile d’imaginer comment le code pour un simple message de log peut devenir beaucoup verbeux. Il y a beaucoup plus de lignes de code dédié à l'affichage des traces plus que de la réelle logique métier! Je reste totalement abasourdie que la communauté Java n’a pas encore trouvé mieux depuis 10 ans."

#. Tag: para
#: Concepts.xml:874
#, no-c-format
msgid "Seam provides a logging API that simplifies this code significantly:"
msgstr "Seam fourni un API d'affichage des traces qui simplifie significativement  le code :"

#. Tag: programlisting
#: Concepts.xml:878
#, no-c-format
msgid ""
"<![CDATA[@Logger private Log log;\n"
"        \n"
"public Order createOrder(User user, Product product, int quantity) {\n"
"    log.debug(\"Creating new order for user: #0 product: #1 quantity: #2\", user.username(), product.name(), quantity);\n"
"    return new Order(user, product, quantity);\n"
"}]]>"
msgstr ""
"<![CDATA[@Logger private Log log;\n"
"        \n"
"public Order createOrder(User user, Product product, int quantity) {\n"
"    log.debug(\"Creating new order for user: #0 product: #1 quantity: #2\", user.username(), product.name(), quantity);\n"
"    return new Order(user, product, quantity);\n"
"}]]>"

#. Tag: para
#: Concepts.xml:880
#, no-c-format
msgid "It doesn't matter if you declare the <literal>log</literal> variable static or not &#8212; it will work either way, except for entity bean components which require the <literal>log</literal> variable to be static."
msgstr "Il n’est pas utile si vous déclarez la variable  <literal>log</literal> statique ou non&#8212;  elle va fonctionner dans tous les cas, à l’exception des composants bean entité qui demande à la variable de  <literal>log</literal> d'être statique."

#. Tag: para
#: Concepts.xml:886
#, no-c-format
msgid "Note that we don't need the noisy <literal>if ( log.isDebugEnabled() )</literal> guard, since string concatenation happens <emphasis>inside</emphasis> the <literal>debug()</literal> method. Note also that we don't usually need to specify the log category explicitly, since Seam knows what component it is injecting the <literal>Log</literal> into."
msgstr "Notez que nous n’avons pas besoin d’être touffu <literal>si ( log.isDebugEnabled() )</literal> conserver, depuis la concaténation des chaines de caractères apparaissent <emphasis>dans</emphasis> la méthode <literal>debug()</literal>.Notez aussi que nous n’avons habituellement pas besoin de spécifier la catégorie de log explicitement, car Seam connaît quel composant au sein du quel il va injecter le <literal>Log</literal>. "

#. Tag: para
#: Concepts.xml:901
#, no-c-format
msgid "If <literal>User</literal> and <literal>Product</literal> are Seam components available in the current contexts, it gets even better:"
msgstr "Si <literal>User</literal> et <literal>Product</literal> sont des composants Seam disponible dans les contextes courant, il n’y a pas mieux : "

#. Tag: programlisting
#: Concepts.xml:906
#, no-c-format
msgid ""
"<![CDATA[@Logger private Log log;\n"
"        \n"
"public Order createOrder(User user, Product product, int quantity) {\n"
"    log.debug(\"Creating new order for user: #{user.username} product: #{product.name} quantity: #0\", quantity);\n"
"    return new Order(user, product, quantity);\n"
"}]]>"
msgstr ""
"<![CDATA[@Logger private Log log;\n"
"        \n"
"public Order createOrder(User user, Product product, int quantity) {\n"
"    log.debug(\"Creating new order for user: #{user.username} product: #{product.name} quantity: #0\", quantity);\n"
"    return new Order(user, product, quantity);\n"
"}]]>"

#. Tag: para
#: Concepts.xml:908
#, no-c-format
msgid "Seam logging automagically chooses whether to send output to log4j or JDK logging. If log4j is in the classpath, Seam with use it. If it is not, Seam will use JDK logging."
msgstr "Seam logue auto-magiquement choisi s’il faut envoyer la sortie vers log4j ou vers le logging JDK. Si log4j est dans le classpath, Seam va l’utiliser. Si ce n’est pas le cas, Seam va utiliser le logging JDK."

#. Tag: title
#: Concepts.xml:916
#, no-c-format
msgid "The <literal>Mutable</literal> interface and <literal>@ReadOnly</literal>"
msgstr " Les interfaces <literal>Mutable</literal> et <literal>@ReadOnly</literal>"

#. Tag: para
#: Concepts.xml:917
#, no-c-format
msgid "Many application servers feature an amazingly broken implementation of <literal>HttpSession</literal> clustering, where changes to the state of mutable objects bound to the session are only replicated when the application calls <literal>setAttribute()</literal> explicitly. This is a source of bugs that can not effectively be tested for at development time, since they will only manifest when failover occurs. Furthermore, the actual replication message contains the entire serialized object graph bound to the session attribute, which is inefficient."
msgstr "Plusieurs serveurs d’applications fonctionnent comme d’incroyable implémentation brissant le clustering <literal>HttpSession</literal> quand les modifications d’état d’objet mutables relié à une session sont seulement répliqués quand l’application appelle  <literal>setAttribute()</literal> explicitement. Ceci est la source de bugs qui ne peuvent pas effectivement être testé pendant le temps de développement, jusqu’à qu’ils se manifestent quand les erreurs surviennent. En outre, le message actuel répliqué contient le graphe d’objet intégralement sérialisé relié à l’attribut de la session, ce qui est inefficace."

#. Tag: para
#: Concepts.xml:926
#, no-c-format
msgid "Of course, EJB stateful session beans must perform automatic dirty checking and replication of mutable state and a sophisticated EJB container can introduce optimizations such as attribute-level replication. Unfortunately, not all Seam users have the good fortune to be working in an environment that supports EJB 3.0. So, for session and conversation scoped JavaBean and entity bean components, Seam provides an extra layer of cluster-safe state management over the top of the web container session clustering."
msgstr "Bien sur, les beans de session avec état EJB peuvent réaliser automatiquement la sale vérification et la réplication des états mutés et un containeur EJB sophistiqué peut introduire des optimisations comme la réplication au niveau attribut. Malheureusement, tous les utilisateurs de Seam n’ont la bonne surprise de travailler dans un environnement qui supporte EJB3.0. Donc, pour la session et le JavaBean d’étendue conversationnelle et les composants bean entité, Seam propose une couche additionnelle pour le gestionnaire d’état sécurisé pour le cluster au dessus du clustering de session du container web."

#. Tag: para
#: Concepts.xml:934
#, no-c-format
msgid "For session or conversation scoped JavaBean components, Seam automatically forces replication to occur by calling <literal>setAttribute()</literal> once in every request that the component was invoked by the application. Of course, this strategy is inefficient for read-mostly components. You can control this behavior by implementing the <literal>org.jboss.seam.core.Mutable</literal> interface, or by extending <literal>org.jboss.seam.core.AbstractMutable</literal>, and writing your own dirty-checking logic inside the component. For example,"
msgstr "Pour la session ou des composants de JavaBeans d’étendue conversationnel, Seam automatiquement force la réplication qui survient en appelant<literal>setAttribute()</literal> une fois sur chaque requète quand le composant est invoqué par l'application.Bien sur, cette stratégie est inéficace pour les composants principalement en lecture seul. Vous pouvez controler cette fonctionnalité en implémentant l'interface <literal>org.jboss.seam.core.Mutable</literal> et écrire votre propre logique de sale-vérification dans votre composant. Par exemple :"

#. Tag: programlisting
#: Concepts.xml:943
#, no-c-format
msgid ""
"<![CDATA[@Name(\"account\")\n"
"public class Account extends AbstractMutable\n"
"{\n"
"    private BigDecimal balance;\n"
"    \n"
"    public void setBalance(BigDecimal balance)\n"
"    {\n"
"        setDirty(this.balance, balance);\n"
"        this.balance = balance;\n"
"    }\n"
"    \n"
"    public BigDecimal getBalance()\n"
"    {\n"
"        return balance;\n"
"    }\n"
"    \n"
"    ...\n"
"    \n"
"}]]>"
msgstr ""
"<![CDATA[@Name(\"account\")\n"
"public class Account extends AbstractMutable\n"
"{\n"
"    private BigDecimal balance;\n"
"    \n"
"    public void setBalance(BigDecimal balance)\n"
"    {\n"
"        setDirty(this.balance, balance);\n"
"        this.balance = balance;\n"
"    }\n"
"    \n"
"    public BigDecimal getBalance()\n"
"    {\n"
"        return balance;\n"
"    }\n"
"    \n"
"    ...\n"
"    \n"
"}]]>"

#. Tag: para
#: Concepts.xml:945
#, no-c-format
msgid "Or, you can use the <literal>@ReadOnly</literal> annotation to achieve a similar effect:"
msgstr "Ou, vous pouvez utiliser l’annotation  @ReadOnly pour obtenir un effet similaire : "

#. Tag: programlisting
#: Concepts.xml:949
#, no-c-format
msgid ""
"<![CDATA[@Name(\"account\")\n"
"public class Account\n"
"{\n"
"    private BigDecimal balance;\n"
"    \n"
"    public void setBalance(BigDecimal balance)\n"
"    {\n"
"        this.balance = balance;\n"
"    }\n"
"    \n"
"    @ReadOnly\n"
"    public BigDecimal getBalance()\n"
"    {\n"
"        return balance;\n"
"    }\n"
"    \n"
"    ...\n"
"    \n"
"}]]>"
msgstr ""
"<![CDATA[@Name(\"account\")\n"
"public class Account\n"
"{\n"
"    private BigDecimal balance;\n"
"    \n"
"    public void setBalance(BigDecimal balance)\n"
"    {\n"
"        this.balance = balance;\n"
"    }\n"
"    \n"
"    @ReadOnly\n"
"    public BigDecimal getBalance()\n"
"    {\n"
"        return balance;\n"
"    }\n"
"    \n"
"    ...\n"
"    \n"
"}]]>"

#. Tag: para
#: Concepts.xml:951
#, no-c-format
msgid "For session or conversation scoped entity bean components, Seam automatically forces replication to occur by calling <literal>setAttribute()</literal> once in every request, <emphasis>unless the (conversation-scoped) entity is currently associated with a Seam-managed persistence context, in which case no replication is needed</emphasis>. This strategy is not necessarily efficient, so session or conversation scope entity beans should be used with care. You can always write a stateful session bean or JavaBean component to \"manage\" the entity bean instance. For example,"
msgstr "Pour la session ou pour des composants bean entité d’étendue conversation, Seam automatiquement forces la réplication qui intervient en appelant <literal>setAttribute()</literal> une fois par requête, <emphasis>à moins que l'entité (d'étendue conversationnelle) ne soit actuellement associée avec le contexte de persistance gérée par Seam, dans ce cas aucune réplication n'est requise</emphasis>. Cette stratégie n'est pas nécéssairement efficace, donc une session ou des beans entité d'édendue conversationnelle devraient l’utiliser avec prudence. Vous devez toujours écrire un bean session avec état ou un composant JavaBean pour \"gérer\" l’instance du bean entité.  Par exemple,"

#. Tag: programlisting
#: Concepts.xml:960
#, no-c-format
msgid ""
"<![CDATA[@Stateful\n"
"@Name(\"account\")\n"
"public class AccountManager extends AbstractMutable\n"
"{\n"
"    private Account account; // an entity bean\n"
"    \n"
"    @Unwrap\n"
"    public Account getAccount()\n"
"    {\n"
"        return account;\n"
"    }\n"
"    \n"
"    ...\n"
"    \n"
"}]]>"
msgstr ""
"<![CDATA[@Stateful\n"
"@Name(\"account\")\n"
"public class AccountManager extends AbstractMutable\n"
"{\n"
"    private Account account; // an entity bean\n"
"    \n"
"    @Unwrap\n"
"    public Account getAccount()\n"
"    {\n"
"        return account;\n"
"    }\n"
"    \n"
"    ...\n"
"    \n"
"}]]>"

#. Tag: para
#: Concepts.xml:962
#, no-c-format
msgid "Note that the <literal>EntityHome</literal> class in the Seam Application Framework provides a great example of managing an entity bean instance using a Seam component."
msgstr "Notez que la classe <literal>EntityHome</literal> dans le Seam Application Framework fourni un bel exemple de gestion d’une instance bean entité utilisant un composant Seam."

#. Tag: title
#: Concepts.xml:970
#, no-c-format
msgid "Factory and manager components"
msgstr "Fabrique et composants gestionnaire"

#. Tag: para
#: Concepts.xml:971
#, no-c-format
msgid "We often need to work with objects that are not Seam components. But we still want to be able to inject them into our components using <literal>@In</literal> and use them in value and method binding expressions, etc. Sometimes, we even need to tie them into the Seam context lifecycle (<literal>@Destroy</literal>, for example). So the Seam contexts can contain objects which are not Seam components, and Seam provides a couple of nice features that make it easier to work with non-component objects bound to contexts."
msgstr "Nous avons souvent besoin de travailler avec des objets qui ne sont pas des composants Seam. Mais nous continuons à vouloir être capable de les injecter dans notre composants en utilisant <literal>@In</literal> et de les utiliser en tant que valeur et méthode reliées aux expressions, etc. De temps en temps, nous avons même besoin de les attacher dans le cycle de vie du contexte de Seam (<literal>@Destroy</literal>, par exemple). Donc les contextes de Seam peuvent obtenir des objets qui ne sont pas des composants Seam et Seam fourni quelques fonctionnalités sympa qui rendent plus facile le travail avec les objets non-composants reliés aux contextes."

#. Tag: para
#: Concepts.xml:979
#, no-c-format
msgid "The <emphasis>factory component pattern</emphasis> lets a Seam component act as the instantiator for a non-component object. A <emphasis>factory method</emphasis> will be called when a context variable is referenced but has no value bound to it. We define factory methods using the <literal>@Factory</literal> annotation. The factory method binds a value to the context variable, and determines the scope of the bound value. There are two styles of factory method. The first style returns a value, which is bound to the context by Seam:"
msgstr "Le <emphasis>modèle de conception fabrique de composant</emphasis> autorise un composant Seam à agir comme l’instanciateur pour un objet non-composant. Une <emphasis>méthode fabrique</emphasis> va être appelée quand une variable du contexte est référencée mais n’a pas de valeur reliée à elle. Nous définissons des méthodes fabrique en utilisant l’annotation <literal>@Factory</literal>. La méthode fabrique relie une valeur à une variable de contexte et détermine l’étendue de la valeur liée. Il y a deux types de méthode fabrique. La première méthode retourne une valeur, qui est relié au contexte par Seam :"

#. Tag: programlisting
#: Concepts.xml:988
#, no-c-format
msgid ""
"<![CDATA[@Factory(scope=CONVERSATION)\n"
"public List<Customer> getCustomerList() { \n"
"    return ... ;\n"
"} ]]>"
msgstr ""
"<![CDATA[@Factory(scope=CONVERSATION)\n"
"public List<Customer> getCustomerList() { \n"
"    return ... ;\n"
"} ]]>"

#. Tag: para
#: Concepts.xml:990
#, no-c-format
msgid "The second style is a method of type <literal>void</literal> which binds the value to the context variable itself:"
msgstr "Le second style est une méthode de type void qui relie cette valeur à la variable de contexte elle-même : "

#. Tag: programlisting
#: Concepts.xml:995
#, no-c-format
msgid ""
"<![CDATA[@DataModel List<Customer> customerList;\n"
"\n"
"@Factory(\"customerList\")\n"
"public void initCustomerList() { \n"
"    customerList = ...  ;\n"
"} ]]>"
msgstr ""
"<![CDATA[@DataModel List<Customer> customerList;\n"
"\n"
"@Factory(\"customerList\")\n"
"public void initCustomerList() { \n"
"    customerList = ...  ;\n"
"} ]]>"

#. Tag: para
#: Concepts.xml:997
#, no-c-format
msgid "In both cases, the factory method is called when we reference the <literal>customerList</literal> context variable and its value is null, and then has no further part to play in the lifecycle of the value. An even more powerful pattern is the <emphasis>manager component pattern</emphasis>. In this case, we have a Seam component that is bound to a context variable, that manages the value of the context variable, while remaining invisible to clients."
msgstr "Dans les deux cas, la méthode fabrique est appelée quand nous référençons la variable de contexte <literal>customerList</literal>  et cette valeur est null, et alors n’a absolument pas à intervenir dans le cycle de vie de la valeur. Et même un patron de conception plus puisssant est  <emphasis>le pattron de conception gestionnaire de composant</emphasis>. Dans ce cas, nous avons un composant Seam qui est relié à une variable de contexte qui gère la valeur de la variable de contexte restant invisible aux clients. "

#. Tag: para
#: Concepts.xml:1005
#, no-c-format
msgid "A manager component is any component with an <literal>@Unwrap</literal> method. This method returns the value that will be visable to clients, and is called <emphasis>every time</emphasis> a context variable is referenced."
msgstr "Un composant gestionnaire est n’importe quel composant avec une méthode <literal>@Unwrap</literal>. Cette méthode retourne la valeur qui va être visible pour les clients, et elle est appelée<emphasis>à chaque fois</emphasis> qu'une variable de contexte est référencée."

#. Tag: programlisting
#: Concepts.xml:1013
#, no-c-format
msgid ""
"<![CDATA[@Name(\"customerList\")\n"
"@Scope(CONVERSATION)\n"
"public class CustomerListManager\n"
"{\n"
"    ...\n"
"    \n"
"    @Unwrap\n"
"    public List<Customer> getCustomerList() { \n"
"        return ... ;\n"
"    }\n"
"}]]>"
msgstr ""
"<![CDATA[@Name(\"customerList\")\n"
"@Scope(CONVERSATION)\n"
"public class CustomerListManager\n"
"{\n"
"    ...\n"
"    \n"
"    @Unwrap\n"
"    public List<Customer> getCustomerList() { \n"
"        return ... ;\n"
"    }\n"
"}]]>"

#. Tag: para
#: Concepts.xml:1015
#, no-c-format
msgid "The manager component pattern is especially useful if we have an object where you need more control over the lifecycle of the component. For example, if you have a heavyweight object that needs a cleanup operation when the context ends you could <literal>@Unwrap</literal> the object, and perform cleanup in the <literal>@Destroy</literal> method of the manager component."
msgstr "Le patron de conception gestionnaire est particulièrement utile si nous avons un objet où nous avons besoin de contrôler le cycle de vie du composant. Par exemple, si vous avez des objets très lourds qui ont besoin d’opération de nettoyage quand le contexte s’arrête, vous pouvez  <literal>@Unwrap</literal> l'objet et réaliser un nettoyage dans la méthode <literal>@Destroy</literal>  du gestionnaire."

#. Tag: programlisting
#: Concepts.xml:1022
#, no-c-format
msgid ""
"<![CDATA[@Name(\"hens\")\n"
"@Scope(APPLICATION) \n"
"public class HenHouse\n"
"{\n"
"    Set<Hen> hens;\n"
"    \n"
"    @In(required=false) Hen hen;\n"
"    \n"
"    @Unwrap\n"
"    public List<Hen> getHens()\n"
"    {\n"
"        if (hens == null)\n"
"        {\n"
"            // Setup our hens\n"
"        }\n"
"        return hens;\n"
"    }\n"
"    \n"
"    @Observer({\"chickBorn\", \"chickenBoughtAtMarket\"})\n"
"    public addHen()\n"
"    {\n"
"        hens.add(hen);\n"
"    }\n"
"    \n"
"    @Observer(\"chickenSoldAtMarket\")\n"
"    public removeHen()\n"
"    {\n"
"        hens.remove(hen);\n"
"    }\n"
"    \n"
"    @Observer(\"foxGetsIn\")\n"
"    public removeAllHens()\n"
"    {\n"
"        hens.clear();\n"
"    }\n"
"    ...\n"
"}]]>"
msgstr ""
"<![CDATA[@Name(\"hens\")\n"
"@Scope(APPLICATION) \n"
"public class HenHouse\n"
"{\n"
"    Set<Hen> hens;\n"
"    \n"
"    @In(required=false) Hen hen;\n"
"    \n"
"    @Unwrap\n"
"    public List<Hen> getHens()\n"
"    {\n"
"        if (hens == null)\n"
"        {\n"
"            // Setup our hens\n"
"        }\n"
"        return hens;\n"
"    }\n"
"    \n"
"    @Observer({\"chickBorn\", \"chickenBoughtAtMarket\"})\n"
"    public addHen()\n"
"    {\n"
"        hens.add(hen);\n"
"    }\n"
"    \n"
"    @Observer(\"chickenSoldAtMarket\")\n"
"    public removeHen()\n"
"    {\n"
"        hens.remove(hen);\n"
"    }\n"
"    \n"
"    @Observer(\"foxGetsIn\")\n"
"    public removeAllHens()\n"
"    {\n"
"        hens.clear();\n"
"    }\n"
"    ...\n"
"}]]>"

#. Tag: para
#: Concepts.xml:1024
#, no-c-format
msgid "Here the managed component observes many events which change the underlying object. The component manages these actions itself, and because the object is unwrapped on every access, a consistent view is provided."
msgstr "Ici le composant gestionnaire observe tous les évènement qui modifie l'objet sous-jacent. Le composant gère ces actions lui-même, et parce que l'objet est empaqueté  donc à chaque accès, une vue cohérante est fournie."

